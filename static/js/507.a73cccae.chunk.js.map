{"version":3,"file":"static/js/507.a73cccae.chunk.js","mappings":"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","sources":["../node_modules/@supabase/functions-js/src/types.ts","../node_modules/@supabase/functions-js/src/FunctionsClient.ts","../node_modules/@supabase/functions-js/src/helper.ts","../node_modules/@supabase/postgrest-js/src/PostgrestBuilder.ts","../node_modules/@supabase/postgrest-js/src/PostgrestTransformBuilder.ts","../node_modules/@supabase/postgrest-js/src/PostgrestFilterBuilder.ts","../node_modules/@supabase/postgrest-js/src/PostgrestQueryBuilder.ts","../node_modules/@supabase/postgrest-js/src/version.ts","../node_modules/@supabase/postgrest-js/src/constants.ts","../node_modules/@supabase/postgrest-js/src/PostgrestClient.ts","../node_modules/@supabase/realtime-js/src/lib/version.ts","../node_modules/@supabase/realtime-js/src/lib/constants.ts","../node_modules/@supabase/realtime-js/src/RealtimePresence.ts","../node_modules/@supabase/realtime-js/src/lib/transformers.ts","../node_modules/@supabase/realtime-js/src/lib/timer.ts","../node_modules/@supabase/realtime-js/src/lib/serializer.ts","../node_modules/@supabase/realtime-js/src/lib/push.ts","../node_modules/@supabase/realtime-js/src/RealtimeChannel.ts","../node_modules/@supabase/realtime-js/src/RealtimeClient.ts","../node_modules/@supabase/storage-js/src/lib/errors.ts","../node_modules/@supabase/storage-js/src/lib/helpers.ts","../node_modules/@supabase/storage-js/src/lib/fetch.ts","../node_modules/@supabase/storage-js/src/packages/StorageFileApi.ts","../node_modules/@supabase/storage-js/src/lib/version.ts","../node_modules/@supabase/storage-js/src/lib/constants.ts","../node_modules/@supabase/storage-js/src/packages/StorageBucketApi.ts","../node_modules/@supabase/storage-js/src/StorageClient.ts","../node_modules/@supabase/supabase-js/src/lib/version.ts","../node_modules/@supabase/supabase-js/src/lib/constants.ts","../node_modules/@supabase/supabase-js/src/lib/fetch.ts","../node_modules/@supabase/gotrue-js/src/lib/helpers.ts","../node_modules/@supabase/gotrue-js/src/lib/errors.ts","../node_modules/@supabase/gotrue-js/src/lib/fetch.ts","../node_modules/@supabase/gotrue-js/src/GoTrueAdminApi.ts","../node_modules/@supabase/gotrue-js/src/lib/version.ts","../node_modules/@supabase/gotrue-js/src/lib/constants.ts","../node_modules/@supabase/gotrue-js/src/lib/local-storage.ts","../node_modules/@supabase/gotrue-js/src/lib/polyfills.ts","../node_modules/@supabase/gotrue-js/src/GoTrueClient.ts","../node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts","../node_modules/@supabase/supabase-js/src/SupabaseClient.ts","../node_modules/@supabase/supabase-js/src/lib/helpers.ts","../node_modules/@supabase/supabase-js/src/index.ts","../node_modules/cross-fetch/dist/browser-ponyfill.js","../node_modules/es5-ext/global.js","../node_modules/websocket/lib/browser.js","../node_modules/websocket/lib/version.js"],"sourcesContent":["export type Fetch = typeof fetch\n\n/**\n * Response format\n *\n */\nexport interface FunctionsResponseSuccess<T> {\n  data: T\n  error: null\n}\nexport interface FunctionsResponseFailure {\n  data: null\n  error: any\n}\nexport type FunctionsResponse<T> = FunctionsResponseSuccess<T> | FunctionsResponseFailure\n\nexport class FunctionsError extends Error {\n  context: any\n  constructor(message: string, name = 'FunctionsError', context?: any) {\n    super(message)\n    super.name = name\n    this.context = context\n  }\n}\n\nexport class FunctionsFetchError extends FunctionsError {\n  constructor(context: any) {\n    super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context)\n  }\n}\n\nexport class FunctionsRelayError extends FunctionsError {\n  constructor(context: any) {\n    super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context)\n  }\n}\n\nexport class FunctionsHttpError extends FunctionsError {\n  constructor(context: any) {\n    super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context)\n  }\n}\n\nexport type FunctionInvokeOptions = {\n  /**\n   * Object representing the headers to send with the request.\n   * */\n  headers?: { [key: string]: string }\n  /**\n   * The HTTP verb of the request\n   */\n  method?: 'POST' | 'GET' | 'PUT' | 'PATCH' | 'DELETE'\n  /**\n   * The body of the request.\n   */\n  body?:\n    | File\n    | Blob\n    | ArrayBuffer\n    | FormData\n    | ReadableStream<Uint8Array>\n    | Record<string, any>\n    | string\n}\n","import { resolveFetch } from './helper'\nimport {\n  Fetch,\n  FunctionsFetchError,\n  FunctionsHttpError,\n  FunctionsRelayError,\n  FunctionsResponse,\n  FunctionInvokeOptions,\n} from './types'\n\nexport class FunctionsClient {\n  protected url: string\n  protected headers: Record<string, string>\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    {\n      headers = {},\n      customFetch,\n    }: {\n      headers?: Record<string, string>\n      customFetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = headers\n    this.fetch = resolveFetch(customFetch)\n  }\n\n  /**\n   * Updates the authorization header\n   * @param token - the new jwt token sent in the authorisation header\n   */\n  setAuth(token: string) {\n    this.headers.Authorization = `Bearer ${token}`\n  }\n\n  /**\n   * Invokes a function\n   * @param functionName - The name of the Function to invoke.\n   * @param options - Options for invoking the Function.\n   */\n  async invoke<T = any>(\n    functionName: string,\n    options: FunctionInvokeOptions = {}\n  ): Promise<FunctionsResponse<T>> {\n    try {\n      const { headers, method, body: functionArgs } = options\n\n      let _headers: Record<string, string> = {}\n      let body: any\n      if (\n        functionArgs &&\n        ((headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type')) || !headers)\n      ) {\n        if (\n          (typeof Blob !== 'undefined' && functionArgs instanceof Blob) ||\n          functionArgs instanceof ArrayBuffer\n        ) {\n          // will work for File as File inherits Blob\n          // also works for ArrayBuffer as it is the same underlying structure as a Blob\n          _headers['Content-Type'] = 'application/octet-stream'\n          body = functionArgs\n        } else if (typeof functionArgs === 'string') {\n          // plain string\n          _headers['Content-Type'] = 'text/plain'\n          body = functionArgs\n        } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n          // don't set content-type headers\n          // Request will automatically add the right boundary value\n          body = functionArgs\n        } else {\n          // default, assume this is JSON\n          _headers['Content-Type'] = 'application/json'\n          body = JSON.stringify(functionArgs)\n        }\n      }\n\n      const response = await this.fetch(`${this.url}/${functionName}`, {\n        method: method || 'POST',\n        // headers priority is (high to low):\n        // 1. invoke-level headers\n        // 2. client-level headers\n        // 3. default Content-Type header\n        headers: { ..._headers, ...this.headers, ...headers },\n        body,\n      }).catch((fetchError) => {\n        throw new FunctionsFetchError(fetchError)\n      })\n\n      const isRelayError = response.headers.get('x-relay-error')\n      if (isRelayError && isRelayError === 'true') {\n        throw new FunctionsRelayError(response)\n      }\n\n      if (!response.ok) {\n        throw new FunctionsHttpError(response)\n      }\n\n      let responseType = (response.headers.get('Content-Type') ?? 'text/plain').split(';')[0].trim()\n      let data: any\n      if (responseType === 'application/json') {\n        data = await response.json()\n      } else if (responseType === 'application/octet-stream') {\n        data = await response.blob()\n      } else if (responseType === 'multipart/form-data') {\n        data = await response.formData()\n      } else {\n        // default to text\n        data = await response.text()\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n}\n","import { Fetch } from './types'\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n","import crossFetch from 'cross-fetch'\n\nimport type { Fetch, PostgrestSingleResponse } from './types'\n\nexport default abstract class PostgrestBuilder<Result>\n  implements PromiseLike<PostgrestSingleResponse<Result>>\n{\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url: URL\n  protected headers: Record<string, string>\n  protected schema?: string\n  protected body?: unknown\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected allowEmpty: boolean\n\n  constructor(builder: PostgrestBuilder<Result>) {\n    this.method = builder.method\n    this.url = builder.url\n    this.headers = builder.headers\n    this.schema = builder.schema\n    this.body = builder.body\n    this.shouldThrowOnError = builder.shouldThrowOnError\n    this.signal = builder.signal\n    this.allowEmpty = builder.allowEmpty\n\n    if (builder.fetch) {\n      this.fetch = builder.fetch\n    } else if (typeof fetch === 'undefined') {\n      this.fetch = crossFetch\n    } else {\n      this.fetch = fetch\n    }\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  then<TResult1 = PostgrestSingleResponse<Result>, TResult2 = never>(\n    onfulfilled?:\n      | ((value: PostgrestSingleResponse<Result>) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema\n    } else {\n      this.headers['Content-Profile'] = this.schema\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json'\n    }\n\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count: number | null = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text()\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = body\n          } else if (\n            this.headers['Accept'] &&\n            this.headers['Accept'].includes('application/vnd.pgrst.plan+text')\n          ) {\n            data = body\n          } else {\n            data = JSON.parse(body)\n          }\n        }\n\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (Array.isArray(error) && res.status === 404) {\n            data = []\n            error = null\n            status = 200\n            statusText = 'OK'\n          }\n        } catch {\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (res.status === 404 && body === '') {\n            status = 204\n            statusText = 'No Content'\n          } else {\n            error = {\n              message: body,\n            }\n          }\n        }\n\n        if (error && this.allowEmpty && error?.details?.includes('Results contain 0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw error\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`,\n          details: `${fetchError?.stack ?? ''}`,\n          hint: '',\n          code: `${fetchError?.code ?? ''}`,\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: '',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n}\n","import PostgrestBuilder from './PostgrestBuilder'\nimport { GetResult } from './select-query-parser'\nimport { GenericSchema } from './types'\n\nexport default class PostgrestTransformBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result\n> extends PostgrestBuilder<Result> {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select<Query extends string = '*', NewResultOne = GetResult<Schema, Row, Query>>(\n    columns?: Query\n  ): PostgrestTransformBuilder<Schema, Row, NewResultOne[]> {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (this.headers['Prefer']) {\n      this.headers['Prefer'] += ','\n    }\n    this.headers['Prefer'] += 'return=representation'\n    return this as unknown as PostgrestTransformBuilder<Schema, Row, NewResultOne[]>\n  }\n\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\n  ): this\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable: string }\n  ): this\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order foreign tables, but it doesn't affect the ordering of the\n   * current table.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.foreignTable - Set this to order a foreign table by foreign\n   * columns\n   */\n  order(\n    column: string,\n    {\n      ascending = true,\n      nullsFirst,\n      foreignTable,\n    }: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string } = {}\n  ): this {\n    const key = foreignTable ? `${foreignTable}.order` : 'order'\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.foreignTable - Set this to limit rows of foreign tables\n   * instead of the current table\n   */\n  limit(count: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limit the query result by `from` and `to` inclusively.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.foreignTable - Set this to limit rows of foreign tables\n   * instead of the current table\n   */\n  range(from: number, to: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\n  >(): PostgrestBuilder<ResultOne> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    return this as PostgrestBuilder<ResultOne>\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\n  >(): PostgrestBuilder<ResultOne | null> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    this.allowEmpty = true\n    return this as PostgrestBuilder<ResultOne | null>\n  }\n\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv(): PostgrestBuilder<string> {\n    this.headers['Accept'] = 'text/csv'\n    return this as PostgrestBuilder<string>\n  }\n\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson(): PostgrestBuilder<Record<string, unknown>> {\n    this.headers['Accept'] = 'application/geo+json'\n    return this as PostgrestBuilder<Record<string, unknown>>\n  }\n\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text',\n  }: {\n    analyze?: boolean\n    verbose?: boolean\n    settings?: boolean\n    buffers?: boolean\n    wal?: boolean\n    format?: 'json' | 'text'\n  } = {}): PostgrestBuilder<Record<string, unknown>[]> | PostgrestBuilder<string> {\n    const options = [\n      analyze ? 'analyze' : null,\n      verbose ? 'verbose' : null,\n      settings ? 'settings' : null,\n      buffers ? 'buffers' : null,\n      wal ? 'wal' : null,\n    ]\n      .filter(Boolean)\n      .join('|')\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = this.headers['Accept']\n    this.headers[\n      'Accept'\n    ] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\n    if (format === 'json') return this as PostgrestBuilder<Record<string, unknown>[]>\n    else return this as PostgrestBuilder<string>\n  }\n\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback(): this {\n    if ((this.headers['Prefer'] ?? '').trim().length > 0) {\n      this.headers['Prefer'] += ',tx=rollback'\n    } else {\n      this.headers['Prefer'] = 'tx=rollback'\n    }\n    return this\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   */\n  returns<NewResult>(): PostgrestTransformBuilder<Schema, Row, NewResult> {\n    return this as unknown as PostgrestTransformBuilder<Schema, Row, NewResult>\n  }\n}\n","import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { GenericSchema } from './types'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n\nexport default class PostgrestFilterBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result\n> extends PostgrestTransformBuilder<Schema, Row, Result> {\n  eq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  eq(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  neq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  neq(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\n  likeAllOf(column: string, patterns: string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\n  likeAnyOf(column: string, patterns: string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\n  ilikeAllOf(column: string, patterns: string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\n  ilikeAnyOf(column: string, patterns: string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  in<ColumnName extends string & keyof Row>(column: ColumnName, values: Row[ColumnName][]): this\n  in(column: string, values: unknown[]): this\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in(column: string, values: unknown[]): this {\n    const cleanedValues = values\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][] | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][] | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][]\n  ): this\n  overlaps(column: string, value: string | unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param foreignTable - Set this to filter on foreign tables instead of the\n   * current table\n   */\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = foreignTable ? `${foreignTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n","import PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser'\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\n\nexport default class PostgrestQueryBuilder<\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView\n> {\n  url: URL\n  headers: Record<string, string>\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = headers\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<Query extends string = '*', ResultOne = GetResult<Schema, Relation['Row'], Query>>(\n    columns?: Query,\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], ResultOne[]> {\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<ResultOne[]>)\n  }\n\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null> {\n    const method = 'POST'\n\n    const prefersHeaders = []\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default')\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null> {\n    const method = 'POST'\n\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default')\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null> {\n    const method = 'PATCH'\n    const prefersHeaders = []\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], null> {\n    const method = 'DELETE'\n    const prefersHeaders = []\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n}\n","export const version = '1.6.0'\n","import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version}` }\n","import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport { DEFAULT_HEADERS } from './constants'\nimport { Fetch, GenericSchema } from './types'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  url: string\n  headers: Record<string, string>\n  schema?: SchemaName\n  fetch?: Fetch\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: SchemaName\n      fetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View>\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder<Schema, any>(url, {\n      headers: { ...this.headers },\n      schema: this.schema,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<\n    FunctionName extends string & keyof Schema['Functions'],\n    Function_ extends Schema['Functions'][FunctionName]\n  >(\n    fn: FunctionName,\n    args: Function_['Args'] = {},\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    Schema,\n    Function_['Returns'] extends any[]\n      ? Function_['Returns'][number] extends Record<string, unknown>\n        ? Function_['Returns'][number]\n        : never\n      : never,\n    Function_['Returns']\n  > {\n    let method: 'HEAD' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    if (head) {\n      method = 'HEAD'\n      Object.entries(args).forEach(([name, value]) => {\n        url.searchParams.append(name, `${value}`)\n      })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = { ...this.headers }\n    if (count) {\n      headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<Function_['Returns']>)\n  }\n}\n","export const version = '2.7.2'\n","import { version } from './version'\n\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${version}` }\n\nexport const VSN: string = '1.0.0'\n\nexport const DEFAULT_TIMEOUT = 10000\n\nexport const WS_CLOSE_NORMAL = 1000\n\nexport enum SOCKET_STATES {\n  connecting = 0,\n  open = 1,\n  closing = 2,\n  closed = 3,\n}\n\nexport enum CHANNEL_STATES {\n  closed = 'closed',\n  errored = 'errored',\n  joined = 'joined',\n  joining = 'joining',\n  leaving = 'leaving',\n}\n\nexport enum CHANNEL_EVENTS {\n  close = 'phx_close',\n  error = 'phx_error',\n  join = 'phx_join',\n  reply = 'phx_reply',\n  leave = 'phx_leave',\n  access_token = 'access_token',\n}\n\nexport enum TRANSPORTS {\n  websocket = 'websocket',\n}\n\nexport enum CONNECTION_STATE {\n  Connecting = 'connecting',\n  Open = 'open',\n  Closing = 'closing',\n  Closed = 'closed',\n}\n","/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\n\nimport type {\n  PresenceOpts,\n  PresenceOnJoinCallback,\n  PresenceOnLeaveCallback,\n} from 'phoenix'\nimport type RealtimeChannel from './RealtimeChannel'\n\ntype Presence<T extends { [key: string]: any } = {}> = {\n  presence_ref: string\n} & T\n\nexport type RealtimePresenceState<T extends { [key: string]: any } = {}> = {\n  [key: string]: Presence<T>[]\n}\n\nexport type RealtimePresenceJoinPayload<T extends { [key: string]: any }> = {\n  event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}`\n  key: string\n  currentPresences: Presence<T>[]\n  newPresences: Presence<T>[]\n}\n\nexport type RealtimePresenceLeavePayload<T extends { [key: string]: any }> = {\n  event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}`\n  key: string\n  currentPresences: Presence<T>[]\n  leftPresences: Presence<T>[]\n}\n\nexport enum REALTIME_PRESENCE_LISTEN_EVENTS {\n  SYNC = 'sync',\n  JOIN = 'join',\n  LEAVE = 'leave',\n}\n\ntype PresenceDiff = {\n  joins: RealtimePresenceState\n  leaves: RealtimePresenceState\n}\n\ntype RawPresenceState = {\n  [key: string]: {\n    metas: {\n      phx_ref?: string\n      phx_ref_prev?: string\n      [key: string]: any\n    }[]\n  }\n}\n\ntype RawPresenceDiff = {\n  joins: RawPresenceState\n  leaves: RawPresenceState\n}\n\ntype PresenceChooser<T> = (key: string, presences: Presence[]) => T\n\nexport default class RealtimePresence {\n  state: RealtimePresenceState = {}\n  pendingDiffs: RawPresenceDiff[] = []\n  joinRef: string | null = null\n  caller: {\n    onJoin: PresenceOnJoinCallback\n    onLeave: PresenceOnLeaveCallback\n    onSync: () => void\n  } = {\n    onJoin: () => {},\n    onLeave: () => {},\n    onSync: () => {},\n  }\n\n  /**\n   * Initializes the Presence.\n   *\n   * @param channel - The RealtimeChannel\n   * @param opts - The options,\n   *        for example `{events: {state: 'state', diff: 'diff'}}`\n   */\n  constructor(public channel: RealtimeChannel, opts?: PresenceOpts) {\n    const events = opts?.events || {\n      state: 'presence_state',\n      diff: 'presence_diff',\n    }\n\n    this.channel._on(events.state, {}, (newState: RawPresenceState) => {\n      const { onJoin, onLeave, onSync } = this.caller\n\n      this.joinRef = this.channel._joinRef()\n\n      this.state = RealtimePresence.syncState(\n        this.state,\n        newState,\n        onJoin,\n        onLeave\n      )\n\n      this.pendingDiffs.forEach((diff) => {\n        this.state = RealtimePresence.syncDiff(\n          this.state,\n          diff,\n          onJoin,\n          onLeave\n        )\n      })\n\n      this.pendingDiffs = []\n\n      onSync()\n    })\n\n    this.channel._on(events.diff, {}, (diff: RawPresenceDiff) => {\n      const { onJoin, onLeave, onSync } = this.caller\n\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = RealtimePresence.syncDiff(\n          this.state,\n          diff,\n          onJoin,\n          onLeave\n        )\n\n        onSync()\n      }\n    })\n\n    this.onJoin((key, currentPresences, newPresences) => {\n      this.channel._trigger('presence', {\n        event: 'join',\n        key,\n        currentPresences,\n        newPresences,\n      })\n    })\n\n    this.onLeave((key, currentPresences, leftPresences) => {\n      this.channel._trigger('presence', {\n        event: 'leave',\n        key,\n        currentPresences,\n        leftPresences,\n      })\n    })\n\n    this.onSync(() => {\n      this.channel._trigger('presence', { event: 'sync' })\n    })\n  }\n\n  /**\n   * Used to sync the list of presences on the server with the\n   * client's state.\n   *\n   * An optional `onJoin` and `onLeave` callback can be provided to\n   * react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @internal\n   */\n  private static syncState(\n    currentState: RealtimePresenceState,\n    newState: RawPresenceState | RealtimePresenceState,\n    onJoin: PresenceOnJoinCallback,\n    onLeave: PresenceOnLeaveCallback\n  ): RealtimePresenceState {\n    const state = this.cloneDeep(currentState)\n    const transformedState = this.transformState(newState)\n    const joins: RealtimePresenceState = {}\n    const leaves: RealtimePresenceState = {}\n\n    this.map(state, (key: string, presences: Presence[]) => {\n      if (!transformedState[key]) {\n        leaves[key] = presences\n      }\n    })\n\n    this.map(transformedState, (key, newPresences: Presence[]) => {\n      const currentPresences: Presence[] = state[key]\n\n      if (currentPresences) {\n        const newPresenceRefs = newPresences.map(\n          (m: Presence) => m.presence_ref\n        )\n        const curPresenceRefs = currentPresences.map(\n          (m: Presence) => m.presence_ref\n        )\n        const joinedPresences: Presence[] = newPresences.filter(\n          (m: Presence) => curPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n        const leftPresences: Presence[] = currentPresences.filter(\n          (m: Presence) => newPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n\n        if (joinedPresences.length > 0) {\n          joins[key] = joinedPresences\n        }\n\n        if (leftPresences.length > 0) {\n          leaves[key] = leftPresences\n        }\n      } else {\n        joins[key] = newPresences\n      }\n    })\n\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave)\n  }\n\n  /**\n   * Used to sync a diff of presence join and leave events from the\n   * server, as they happen.\n   *\n   * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n   * `onLeave` callbacks to react to a user joining or leaving from a\n   * device.\n   *\n   * @internal\n   */\n  private static syncDiff(\n    state: RealtimePresenceState,\n    diff: RawPresenceDiff | PresenceDiff,\n    onJoin: PresenceOnJoinCallback,\n    onLeave: PresenceOnLeaveCallback\n  ): RealtimePresenceState {\n    const { joins, leaves } = {\n      joins: this.transformState(diff.joins),\n      leaves: this.transformState(diff.leaves),\n    }\n\n    if (!onJoin) {\n      onJoin = () => {}\n    }\n\n    if (!onLeave) {\n      onLeave = () => {}\n    }\n\n    this.map(joins, (key, newPresences: Presence[]) => {\n      const currentPresences: Presence[] = state[key] ?? []\n      state[key] = this.cloneDeep(newPresences)\n\n      if (currentPresences.length > 0) {\n        const joinedPresenceRefs = state[key].map(\n          (m: Presence) => m.presence_ref\n        )\n        const curPresences: Presence[] = currentPresences.filter(\n          (m: Presence) => joinedPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n\n        state[key].unshift(...curPresences)\n      }\n\n      onJoin(key, currentPresences, newPresences)\n    })\n\n    this.map(leaves, (key, leftPresences: Presence[]) => {\n      let currentPresences: Presence[] = state[key]\n\n      if (!currentPresences) return\n\n      const presenceRefsToRemove = leftPresences.map(\n        (m: Presence) => m.presence_ref\n      )\n      currentPresences = currentPresences.filter(\n        (m: Presence) => presenceRefsToRemove.indexOf(m.presence_ref) < 0\n      )\n\n      state[key] = currentPresences\n\n      onLeave(key, currentPresences, leftPresences)\n\n      if (currentPresences.length === 0) delete state[key]\n    })\n\n    return state\n  }\n\n  /** @internal */\n  private static map<T = any>(\n    obj: RealtimePresenceState,\n    func: PresenceChooser<T>\n  ): T[] {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]))\n  }\n\n  /**\n   * Remove 'metas' key\n   * Change 'phx_ref' to 'presence_ref'\n   * Remove 'phx_ref' and 'phx_ref_prev'\n   *\n   * @example\n   * // returns {\n   *  abc123: [\n   *    { presence_ref: '2', user_id: 1 },\n   *    { presence_ref: '3', user_id: 2 }\n   *  ]\n   * }\n   * RealtimePresence.transformState({\n   *  abc123: {\n   *    metas: [\n   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n   *      { phx_ref: '3', user_id: 2 }\n   *    ]\n   *  }\n   * })\n   *\n   * @internal\n   */\n  private static transformState(\n    state: RawPresenceState | RealtimePresenceState\n  ): RealtimePresenceState {\n    state = this.cloneDeep(state)\n\n    return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n      const presences = state[key]\n\n      if ('metas' in presences) {\n        newState[key] = presences.metas.map((presence) => {\n          presence['presence_ref'] = presence['phx_ref']\n\n          delete presence['phx_ref']\n          delete presence['phx_ref_prev']\n\n          return presence\n        }) as Presence[]\n      } else {\n        newState[key] = presences\n      }\n\n      return newState\n    }, {} as RealtimePresenceState)\n  }\n\n  /** @internal */\n  private static cloneDeep(obj: { [key: string]: any }) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n\n  /** @internal */\n  private onJoin(callback: PresenceOnJoinCallback): void {\n    this.caller.onJoin = callback\n  }\n\n  /** @internal */\n  private onLeave(callback: PresenceOnLeaveCallback): void {\n    this.caller.onLeave = callback\n  }\n\n  /** @internal */\n  private onSync(callback: () => void): void {\n    this.caller.onSync = callback\n  }\n\n  /** @internal */\n  private inPendingSyncState(): boolean {\n    return !this.joinRef || this.joinRef !== this.channel._joinRef()\n  }\n}\n","/**\n * Helpers to convert the change Payload into native JS types.\n */\n\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\n\nexport enum PostgresTypes {\n  abstime = 'abstime',\n  bool = 'bool',\n  date = 'date',\n  daterange = 'daterange',\n  float4 = 'float4',\n  float8 = 'float8',\n  int2 = 'int2',\n  int4 = 'int4',\n  int4range = 'int4range',\n  int8 = 'int8',\n  int8range = 'int8range',\n  json = 'json',\n  jsonb = 'jsonb',\n  money = 'money',\n  numeric = 'numeric',\n  oid = 'oid',\n  reltime = 'reltime',\n  text = 'text',\n  time = 'time',\n  timestamp = 'timestamp',\n  timestamptz = 'timestamptz',\n  timetz = 'timetz',\n  tsrange = 'tsrange',\n  tstzrange = 'tstzrange',\n}\n\ntype Columns = {\n  name: string // the column name. eg: \"user_id\"\n  type: string // the column type. eg: \"uuid\"\n  flags?: string[] // any special flags for the column. eg: [\"key\"]\n  type_modifier?: number // the type modifier. eg: 4294967295\n}[]\n\ntype BaseValue = null | string | number | boolean\ntype RecordValue = BaseValue | BaseValue[]\n\ntype Record = {\n  [key: string]: RecordValue\n}\n\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (\n  columns: Columns,\n  record: Record,\n  options: { skipTypes?: string[] } = {}\n): Record => {\n  const skipTypes = options.skipTypes ?? []\n\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes)\n    return acc\n  }, {} as Record)\n}\n\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (\n  columnName: string,\n  columns: Columns,\n  record: Record,\n  skipTypes: string[]\n): RecordValue => {\n  const column = columns.find((x) => x.name === columnName)\n  const colType = column?.type\n  const value = record[columnName]\n\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value)\n  }\n\n  return noop(value)\n}\n\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type: string, value: RecordValue): RecordValue => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length)\n    return toArray(value, dataType)\n  }\n\n  // If not null, convert to correct type.\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value)\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value)\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value)\n    case PostgresTypes.timestamp:\n      return toTimestampString(value) // Format to be consistent with PostgREST\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value)\n    default:\n      // Return the value for remaining types\n      return noop(value)\n  }\n}\n\nconst noop = (value: RecordValue): RecordValue => {\n  return value\n}\nexport const toBoolean = (value: RecordValue): RecordValue => {\n  switch (value) {\n    case 't':\n      return true\n    case 'f':\n      return false\n    default:\n      return value\n  }\n}\nexport const toNumber = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value)\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue\n    }\n  }\n  return value\n}\nexport const toJson = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value)\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`)\n      return value\n    }\n  }\n  return value\n}\n\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value: RecordValue, type: string): RecordValue => {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  const lastIdx = value.length - 1\n  const closeBrace = value[lastIdx]\n  const openBrace = value[0]\n\n  // Confirm value is a Postgres array by checking curly brackets\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr\n    const valTrim = value.slice(1, lastIdx)\n\n    // TODO: find a better solution to separate Postgres array data\n    try {\n      arr = JSON.parse('[' + valTrim + ']')\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : []\n    }\n\n    return arr.map((val: BaseValue) => convertCell(type, val))\n  }\n\n  return value\n}\n\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T')\n  }\n\n  return value\n}\n","/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n  timer: number | undefined = undefined\n  tries: number = 0\n\n  constructor(public callback: Function, public timerCalc: Function) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n  }\n\n  reset() {\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout() {\n    clearTimeout(this.timer)\n\n    this.timer = <any>setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n","// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\n\nexport default class Serializer {\n  HEADER_LENGTH = 1\n\n  decode(rawPayload: ArrayBuffer | string, callback: Function) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this._binaryDecode(rawPayload))\n    }\n\n    if (typeof rawPayload === 'string') {\n      return callback(JSON.parse(rawPayload))\n    }\n\n    return callback({})\n  }\n\n  private _binaryDecode(buffer: ArrayBuffer) {\n    const view = new DataView(buffer)\n    const decoder = new TextDecoder()\n\n    return this._decodeBroadcast(buffer, view, decoder)\n  }\n\n  private _decodeBroadcast(\n    buffer: ArrayBuffer,\n    view: DataView,\n    decoder: TextDecoder\n  ): {\n    ref: null\n    topic: string\n    event: string\n    payload: { [key: string]: any }\n  } {\n    const topicSize = view.getUint8(1)\n    const eventSize = view.getUint8(2)\n    let offset = this.HEADER_LENGTH + 2\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    const data = JSON.parse(\n      decoder.decode(buffer.slice(offset, buffer.byteLength))\n    )\n\n    return { ref: null, topic: topic, event: event, payload: data }\n  }\n}\n","import { DEFAULT_TIMEOUT } from '../lib/constants'\nimport type RealtimeChannel from '../RealtimeChannel'\n\nexport default class Push {\n  sent: boolean = false\n  timeoutTimer: number | undefined = undefined\n  ref: string = ''\n  receivedResp: {\n    status: string\n    response: { [key: string]: any }\n  } | null = null\n  recHooks: {\n    status: string\n    callback: Function\n  }[] = []\n  refEvent: string | null = null\n  rateLimited: boolean = false\n\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(\n    public channel: RealtimeChannel,\n    public event: string,\n    public payload: { [key: string]: any } = {},\n    public timeout: number = DEFAULT_TIMEOUT\n  ) {}\n\n  resend(timeout: number) {\n    this.timeout = timeout\n    this._cancelRefEvent()\n    this.ref = ''\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n    this.send()\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return\n    }\n    this.startTimeout()\n    this.sent = true\n    const status = this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel._joinRef(),\n    })\n    if (status === 'rate limited') {\n      this.rateLimited = true\n    }\n  }\n\n  updatePayload(payload: { [key: string]: any }): void {\n    this.payload = { ...this.payload, ...payload }\n  }\n\n  receive(status: string, callback: Function) {\n    if (this._hasReceived(status)) {\n      callback(this.receivedResp?.response)\n    }\n\n    this.recHooks.push({ status, callback })\n    return this\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return\n    }\n    this.ref = this.channel.socket._makeRef()\n    this.refEvent = this.channel._replyEventName(this.ref)\n\n    const callback = (payload: any) => {\n      this._cancelRefEvent()\n      this._cancelTimeout()\n      this.receivedResp = payload\n      this._matchReceive(payload)\n    }\n\n    this.channel._on(this.refEvent, {}, callback)\n\n    this.timeoutTimer = <any>setTimeout(() => {\n      this.trigger('timeout', {})\n    }, this.timeout)\n  }\n\n  trigger(status: string, response: any) {\n    if (this.refEvent)\n      this.channel._trigger(this.refEvent, { status, response })\n  }\n\n  destroy() {\n    this._cancelRefEvent()\n    this._cancelTimeout()\n  }\n\n  private _cancelRefEvent() {\n    if (!this.refEvent) {\n      return\n    }\n\n    this.channel._off(this.refEvent, {})\n  }\n\n  private _cancelTimeout() {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = undefined\n  }\n\n  private _matchReceive({\n    status,\n    response,\n  }: {\n    status: string\n    response: Function\n  }) {\n    this.recHooks\n      .filter((h) => h.status === status)\n      .forEach((h) => h.callback(response))\n  }\n\n  private _hasReceived(status: string) {\n    return this.receivedResp && this.receivedResp.status === status\n  }\n}\n","import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport type RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence, {\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\nimport type {\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n} from './RealtimePresence'\nimport * as Transformers from './lib/transformers'\n\nexport type RealtimeChannelOptions = {\n  config: {\n    /**\n     * self option enables client to receive message it broadcast\n     * ack option instructs server to acknowledge that broadcast message was received\n     */\n    broadcast?: { self?: boolean; ack?: boolean }\n    /**\n     * key option is used to track presence payload across clients\n     */\n    presence?: { key?: string }\n  }\n}\n\ntype RealtimePostgresChangesPayloadBase = {\n  schema: string\n  table: string\n  commit_timestamp: string\n  errors: string[]\n}\n\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\n    new: T\n    old: {}\n  }\n\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\n    new: T\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\n    new: {}\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\n  | RealtimePostgresInsertPayload<T>\n  | RealtimePostgresUpdatePayload<T>\n  | RealtimePostgresDeletePayload<T>\n\nexport type RealtimePostgresChangesFilter<\n  T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`\n> = {\n  /**\n   * The type of database change to listen to.\n   */\n  event: T\n  /**\n   * The database schema to listen to.\n   */\n  schema: string\n  /**\n   * The database table to listen to.\n   */\n  table?: string\n  /**\n   * Receive database changes when filter is matched.\n   */\n  filter?: string\n}\n\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'rate limited'\n\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\n  ALL = '*',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n}\n\nexport enum REALTIME_LISTEN_TYPES {\n  BROADCAST = 'broadcast',\n  PRESENCE = 'presence',\n  /**\n   * listen to Postgres changes.\n   */\n  POSTGRES_CHANGES = 'postgres_changes',\n}\n\nexport enum REALTIME_SUBSCRIBE_STATES {\n  SUBSCRIBED = 'SUBSCRIBED',\n  TIMED_OUT = 'TIMED_OUT',\n  CLOSED = 'CLOSED',\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\n}\n\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n **/\nexport default class RealtimeChannel {\n  bindings: {\n    [key: string]: {\n      type: string\n      filter: { [key: string]: any }\n      callback: Function\n      id?: string\n    }[]\n  } = {}\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n\n  constructor(\n    /** Topic name can be any string. */\n    public topic: string,\n    public params: RealtimeChannelOptions = { config: {} },\n    public socket: RealtimeClient\n  ) {\n    this.params.config = {\n      ...{\n        broadcast: { ack: false, self: false },\n        presence: { key: '' },\n      },\n      ...params.config,\n    }\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this._rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this._onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket._remove(this)\n    })\n    this._onError((reason: string) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this._trigger(this._replyEventName(ref), payload)\n    })\n\n    this.presence = new RealtimePresence(this)\n  }\n\n  /** Subscribe registers your client with the server */\n  subscribe(\n    callback?: (status: `${REALTIME_SUBSCRIBE_STATES}`, err?: Error) => void,\n    timeout = this.timeout\n  ): RealtimeChannel {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      const {\n        config: { broadcast, presence },\n      } = this.params\n      this._onError((e: Error) => callback && callback('CHANNEL_ERROR', e))\n      this._onClose(() => callback && callback('CLOSED'))\n\n      const accessTokenPayload: { access_token?: string } = {}\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes:\n          this.bindings.postgres_changes?.map((r) => r.filter) ?? [],\n      }\n\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken\n      }\n\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\n\n      this.joinedOnce = true\n      this._rejoin(timeout)\n\n      this.joinPush\n        .receive(\n          'ok',\n          ({\n            postgres_changes: serverPostgresFilters,\n          }: {\n            postgres_changes: {\n              id: string\n              event: string\n              schema?: string\n              table?: string\n              filter?: string\n            }[]\n          }) => {\n            this.socket.accessToken &&\n              this.socket.setAuth(this.socket.accessToken)\n\n            if (serverPostgresFilters === undefined) {\n              callback && callback('SUBSCRIBED')\n              return\n            } else {\n              const clientPostgresBindings = this.bindings.postgres_changes\n              const bindingsLen = clientPostgresBindings?.length ?? 0\n              const newPostgresBindings = []\n\n              for (let i = 0; i < bindingsLen; i++) {\n                const clientPostgresBinding = clientPostgresBindings[i]\n                const {\n                  filter: { event, schema, table, filter },\n                } = clientPostgresBinding\n                const serverPostgresFilter =\n                  serverPostgresFilters && serverPostgresFilters[i]\n\n                if (\n                  serverPostgresFilter &&\n                  serverPostgresFilter.event === event &&\n                  serverPostgresFilter.schema === schema &&\n                  serverPostgresFilter.table === table &&\n                  serverPostgresFilter.filter === filter\n                ) {\n                  newPostgresBindings.push({\n                    ...clientPostgresBinding,\n                    id: serverPostgresFilter.id,\n                  })\n                } else {\n                  this.unsubscribe()\n                  callback &&\n                    callback(\n                      'CHANNEL_ERROR',\n                      new Error(\n                        'mismatch between server and client bindings for postgres changes'\n                      )\n                    )\n                  return\n                }\n              }\n\n              this.bindings.postgres_changes = newPostgresBindings\n\n              callback && callback('SUBSCRIBED')\n              return\n            }\n          }\n        )\n        .receive('error', (error: { [key: string]: any }) => {\n          callback &&\n            callback(\n              'CHANNEL_ERROR',\n              new Error(\n                JSON.stringify(Object.values(error).join(', ') || 'error')\n              )\n            )\n          return\n        })\n        .receive('timeout', () => {\n          callback && callback('TIMED_OUT')\n          return\n        })\n    }\n\n    return this\n  }\n\n  presenceState<\n    T extends { [key: string]: any } = {}\n  >(): RealtimePresenceState<T> {\n    return this.presence.state as RealtimePresenceState<T>\n  }\n\n  async track(\n    payload: { [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'track',\n        payload,\n      },\n      opts.timeout || this.timeout\n    )\n  }\n\n  async untrack(\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'untrack',\n      },\n      opts\n    )\n  }\n\n  /**\n   * Creates an event handler that listens to changes.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\n    callback: () => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\n  ): RealtimeChannel\n  /**\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\n   * @param callback Function to be invoked when event handler is triggered.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      [key: string]: any\n    }) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES}`,\n    filter: { event: string; [key: string]: string },\n    callback: (payload: any) => void\n  ): RealtimeChannel {\n    return this._on(type, filter, callback)\n  }\n\n  send(\n    payload: { type: string; [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return new Promise((resolve) => {\n      const push = this._push(\n        payload.type,\n        payload,\n        opts.timeout || this.timeout\n      )\n\n      if (push.rateLimited) {\n        resolve('rate limited')\n      }\n\n      if (\n        payload.type === 'broadcast' &&\n        !this.params?.config?.broadcast?.ack\n      ) {\n        resolve('ok')\n      }\n\n      push.receive('ok', () => resolve('ok'))\n      push.receive('timeout', () => resolve('timed out'))\n    })\n  }\n\n  updateJoinPayload(payload: { [key: string]: any }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\n    }\n\n    this.rejoinTimer.reset()\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    return new Promise((resolve) => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n\n      leavePush\n        .receive('ok', () => {\n          onClose()\n          resolve('ok')\n        })\n        .receive('timeout', () => {\n          onClose()\n          resolve('timed out')\n        })\n        .receive('error', () => {\n          resolve('error')\n        })\n\n      leavePush.send()\n\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {})\n      }\n    })\n  }\n\n  /** @internal */\n  _push(\n    event: string,\n    payload: { [key: string]: any },\n    timeout = this.timeout\n  ) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this._canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event: string, payload: any, _ref?: string) {\n    return payload\n  }\n\n  /** @internal */\n  _isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  /** @internal */\n  _joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  /** @internal */\n  _trigger(type: string, payload?: any, ref?: string) {\n    const typeLower = type.toLocaleLowerCase()\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      this.bindings.postgres_changes\n        ?.filter((bind) => {\n          return (\n            bind.filter?.event === '*' ||\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\n          )\n        })\n        .map((bind) => bind.callback(handledPayload, ref))\n    } else {\n      this.bindings[typeLower]\n        ?.filter((bind) => {\n          if (\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\n          ) {\n            if ('id' in bind) {\n              const bindId = bind.id\n              const bindEvent = bind.filter?.event\n              return (\n                bindId &&\n                payload.ids?.includes(bindId) &&\n                (bindEvent === '*' ||\n                  bindEvent?.toLocaleLowerCase() ===\n                    payload.data?.type.toLocaleLowerCase())\n              )\n            } else {\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\n              return (\n                bindEvent === '*' ||\n                bindEvent === payload?.event?.toLocaleLowerCase()\n              )\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower\n          }\n        })\n        .map((bind) => {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            const postgresChanges = handledPayload.data\n            const { schema, table, commit_timestamp, type, errors } =\n              postgresChanges\n            const enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: type,\n              new: {},\n              old: {},\n              errors: errors,\n            }\n            handledPayload = {\n              ...enrichedPayload,\n              ...this._getPayloadRecords(postgresChanges),\n            }\n          }\n          bind.callback(handledPayload, ref)\n        })\n    }\n  }\n\n  /** @internal */\n  _isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /** @internal */\n  _isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /** @internal */\n  _isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /** @internal */\n  _isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  /** @internal */\n  _replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  /** @internal */\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\n    const typeLower = type.toLocaleLowerCase()\n\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback,\n    }\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding)\n    } else {\n      this.bindings[typeLower] = [binding]\n    }\n\n    return this\n  }\n\n  /** @internal */\n  _off(type: string, filter: { [key: string]: any }) {\n    const typeLower = type.toLocaleLowerCase()\n\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      return !(\n        bind.type?.toLocaleLowerCase() === typeLower &&\n        RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n    return this\n  }\n\n  /** @internal */\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /** @internal */\n  private _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this._rejoin()\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  private _onClose(callback: Function) {\n    this._on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  private _onError(callback: Function) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  private _canPush(): boolean {\n    return this.socket.isConnected() && this._isJoined()\n  }\n\n  /** @internal */\n  private _rejoin(timeout = this.timeout): void {\n    if (this._isLeaving()) {\n      return\n    }\n    this.socket._leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /** @internal */\n  private _getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(\n        payload.columns,\n        payload.record\n      )\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(\n        payload.columns,\n        payload.old_record\n      )\n    }\n\n    return records\n  }\n}\n","import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n}\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeChannel[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  eventsPerSecondLimitMs: number = 100\n  inThrottle: boolean = false\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const eventsPerSecond = options?.params?.eventsPerSecond\n    if (eventsPerSecond)\n      this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond)\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this._onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    if (!this.isConnected()) {\n      this.connect()\n    }\n\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): 'rate limited' | void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)()\n        if (isThrottled) {\n          return 'rate limited'\n        }\n      } else {\n        callback()\n      }\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null): void {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token })\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\n    )\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  private _endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  /** @internal */\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n  /** @internal */\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n\n  /** @internal */\n  private _throttle(\n    callback: Function,\n    eventsPerSecondLimitMs: number = this.eventsPerSecondLimitMs\n  ): () => boolean {\n    return () => {\n      if (this.inThrottle) return true\n\n      callback()\n\n      if (eventsPerSecondLimitMs > 0) {\n        this.inThrottle = true\n\n        setTimeout(() => {\n          this.inThrottle = false\n        }, eventsPerSecondLimitMs)\n      }\n\n      return false\n    }\n  }\n}\n","export class StorageError extends Error {\n  protected __isStorageError = true\n\n  constructor(message: string) {\n    super(message)\n    this.name = 'StorageError'\n  }\n}\n\nexport function isStorageError(error: unknown): error is StorageError {\n  return typeof error === 'object' && error !== null && '__isStorageError' in error\n}\n\nexport class StorageApiError extends StorageError {\n  status: number\n\n  constructor(message: string, status: number) {\n    super(message)\n    this.name = 'StorageApiError'\n    this.status = status\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n    }\n  }\n}\n\nexport class StorageUnknownError extends StorageError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'StorageUnknownError'\n    this.originalError = originalError\n  }\n}\n","type Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const resolveResponse = async () => {\n  if (typeof Response === 'undefined') {\n    return (await import('cross-fetch')).Response\n  }\n\n  return Response\n}\n","import { StorageApiError, StorageUnknownError } from './errors'\nimport { resolveResponse } from './helpers'\nimport { FetchParameters } from './types'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst handleError = async (error: unknown, reject: (reason?: any) => void) => {\n  const Res = await resolveResponse()\n\n  if (error instanceof Res) {\n    error\n      .json()\n      .then((err) => {\n        reject(new StorageApiError(_getErrorMessage(err), error.status || 500))\n      })\n      .catch((err) => {\n        reject(new StorageUnknownError(_getErrorMessage(err), err))\n      })\n  } else {\n    reject(new StorageUnknownError(_getErrorMessage(error), error))\n  }\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET') {\n    return params\n  }\n\n  params.headers = { 'Content-Type': 'application/json', ...options?.headers }\n  params.body = JSON.stringify(body)\n  return { ...params, ...parameters }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject))\n  })\n}\n\nexport async function get(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\n}\n\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\n}\n\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\n}\n\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\n}\n","import { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, remove } from '../lib/fetch'\nimport { resolveFetch } from '../lib/helpers'\nimport {\n  FileObject,\n  FileOptions,\n  SearchOptions,\n  FetchParameters,\n  TransformOptions,\n} from '../lib/types'\n\nconst DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc',\n  },\n}\n\nconst DEFAULT_FILE_OPTIONS: FileOptions = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false,\n}\n\ntype FileBody =\n  | ArrayBuffer\n  | ArrayBufferView\n  | Blob\n  | Buffer\n  | File\n  | FormData\n  | NodeJS.ReadableStream\n  | ReadableStream<Uint8Array>\n  | URLSearchParams\n  | string\n\nexport default class StorageFileApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected bucketId?: string\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    bucketId?: string,\n    fetch?: Fetch\n  ) {\n    this.url = url\n    this.headers = headers\n    this.bucketId = bucketId\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  private async uploadOrUpdate(\n    method: 'POST' | 'PUT',\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let body\n      const options = { ...DEFAULT_FILE_OPTIONS, ...fileOptions }\n      const headers: Record<string, string> = {\n        ...this.headers,\n        ...(method === 'POST' && { 'x-upsert': String(options.upsert as boolean) }),\n      }\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n      }\n\n      const cleanPath = this._removeEmptyFolders(path)\n      const _path = this._getFinalPath(cleanPath)\n      const res = await this.fetch(`${this.url}/object/${_path}`, {\n        method,\n        body: body as BodyInit,\n        headers,\n        ...(options?.duplex ? { duplex: options.duplex } : {}),\n      })\n\n      if (res.ok) {\n        return {\n          data: { path: cleanPath },\n          error: null,\n        }\n      } else {\n        const error = await res.json()\n        return { data: null, error }\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Uploads a file to an existing bucket.\n   *\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async upload(\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('POST', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Upload a file with a token generated from `createSignedUploadUrl`.\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param token The token generated from `createSignedUploadUrl`\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async uploadToSignedUrl(\n    path: string,\n    token: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ) {\n    const cleanPath = this._removeEmptyFolders(path)\n    const _path = this._getFinalPath(cleanPath)\n\n    const url = new URL(this.url + `/object/upload/sign/${_path}`)\n    url.searchParams.set('token', token)\n\n    try {\n      let body\n      const options = { upsert: DEFAULT_FILE_OPTIONS.upsert, ...fileOptions }\n      const headers: Record<string, string> = {\n        ...this.headers,\n        ...{ 'x-upsert': String(options.upsert as boolean) },\n      }\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n      }\n\n      const res = await this.fetch(url.toString(), {\n        method: 'PUT',\n        body: body as BodyInit,\n        headers,\n      })\n\n      if (res.ok) {\n        return {\n          data: { path: cleanPath },\n          error: null,\n        }\n      } else {\n        const error = await res.json()\n        return { data: null, error }\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed upload URL.\n   * Signed upload URLs can be used to upload files to the bucket without further authentication.\n   * They are valid for one minute.\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   */\n  async createSignedUploadUrl(\n    path: string\n  ): Promise<\n    | {\n        data: { signedUrl: string; token: string; path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/upload/sign/${_path}`,\n        {},\n        { headers: this.headers }\n      )\n\n      const url = new URL(this.url + data.url)\n\n      const token = url.searchParams.get('token')\n\n      if (!token) {\n        throw new StorageError('No token returned by API')\n      }\n\n      return { data: { signedUrl: url.toString(), path, token }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Replaces an existing file at the specified path with a new one.\n   *\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async update(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('PUT', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Moves an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n   */\n  async move(\n    fromPath: string,\n    toPath: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/move`,\n        { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Copies an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n   */\n  async copy(\n    fromPath: string,\n    toPath: string\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/copy`,\n        { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath },\n        { headers: this.headers }\n      )\n      return { data: { path: data.Key }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  async createSignedUrl(\n    path: string,\n    expiresIn: number,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: { signedUrl: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      let data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${_path}`,\n        { expiresIn, ...(options?.transform ? { transform: options.transform } : {}) },\n        { headers: this.headers }\n      )\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`)\n      data = { signedUrl }\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   */\n  async createSignedUrls(\n    paths: string[],\n    expiresIn: number,\n    options?: { download: string | boolean }\n  ): Promise<\n    | {\n        data: { error: string | null; path: string | null; signedUrl: string }[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${this.bucketId}`,\n        { expiresIn, paths },\n        { headers: this.headers }\n      )\n\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      return {\n        data: data.map((datum: { signedURL: string }) => ({\n          ...datum,\n          signedUrl: datum.signedURL\n            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n            : null,\n        })),\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n   *\n   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  async download(\n    path: string,\n    options?: { transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: Blob\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n    const queryString = transformationQuery ? `?${transformationQuery}` : ''\n\n    try {\n      const _path = this._getFinalPath(path)\n      const res = await get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n        headers: this.headers,\n        noResolveJson: true,\n      })\n      const data = await res.blob()\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n   *\n   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  getPublicUrl(\n    path: string,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): { data: { publicUrl: string } } {\n    const _path = this._getFinalPath(path)\n    const _queryString = []\n\n    const downloadQueryParam = options?.download\n      ? `download=${options.download === true ? '' : options.download}`\n      : ''\n\n    if (downloadQueryParam !== '') {\n      _queryString.push(downloadQueryParam)\n    }\n\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n\n    if (transformationQuery !== '') {\n      _queryString.push(transformationQuery)\n    }\n\n    let queryString = _queryString.join('&')\n    if (queryString !== '') {\n      queryString = `?${queryString}`\n    }\n\n    return {\n      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) },\n    }\n  }\n\n  /**\n   * Deletes files within the same bucket\n   *\n   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n   */\n  async remove(\n    paths: string[]\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/object/${this.bucketId}`,\n        { prefixes: paths },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get file metadata\n   * @param id the file id to retrieve metadata\n   */\n  // async getMetadata(\n  //   id: string\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Update file metadata\n   * @param id the file id to update metadata\n   * @param meta the new file metadata\n   */\n  // async updateMetadata(\n  //   id: string,\n  //   meta: Metadata\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await post(\n  //       this.fetch,\n  //       `${this.url}/metadata/${id}`,\n  //       { ...meta },\n  //       { headers: this.headers }\n  //     )\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Lists all the files within a bucket.\n   * @param path The folder path.\n   */\n  async list(\n    path?: string,\n    options?: SearchOptions,\n    parameters?: FetchParameters\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const body = { ...DEFAULT_SEARCH_OPTIONS, ...options, prefix: path || '' }\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/list/${this.bucketId}`,\n        body,\n        { headers: this.headers },\n        parameters\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  private _getFinalPath(path: string) {\n    return `${this.bucketId}/${path}`\n  }\n\n  private _removeEmptyFolders(path: string) {\n    return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/')\n  }\n\n  private transformOptsToQueryString(transform: TransformOptions) {\n    const params = []\n    if (transform.width) {\n      params.push(`width=${transform.width}`)\n    }\n\n    if (transform.height) {\n      params.push(`height=${transform.height}`)\n    }\n\n    if (transform.resize) {\n      params.push(`resize=${transform.resize}`)\n    }\n\n    if (transform.format) {\n      params.push(`format=${transform.format}`)\n    }\n\n    if (transform.quality) {\n      params.push(`quality=${transform.quality}`)\n    }\n\n    return params.join('&')\n  }\n}\n","// generated by genversion\nexport const version = '2.5.1'\n","import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${version}` }\n","import { DEFAULT_HEADERS } from '../lib/constants'\nimport { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, put, remove } from '../lib/fetch'\nimport { resolveFetch } from '../lib/helpers'\nimport { Bucket } from '../lib/types'\n\nexport default class StorageBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Retrieves the details of all Storage buckets within an existing project.\n   */\n  async listBuckets(): Promise<\n    | {\n        data: Bucket[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing Storage bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to retrieve.\n   */\n  async getBucket(\n    id: string\n  ): Promise<\n    | {\n        data: Bucket\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a new Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are creating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   * @returns newly created bucket id\n   */\n  async createBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n    } = {\n      public: false,\n    }\n  ): Promise<\n    | {\n        data: Pick<Bucket, 'name'>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket`,\n        {\n          id,\n          name: id,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates a Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are updating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   */\n  async updateBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n    }\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await put(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {\n          id,\n          name: id,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Removes all objects inside a single bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to empty.\n   */\n  async emptyBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket/${id}/empty`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n   * You must first `empty()` the bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to delete.\n   */\n  async deleteBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n","import StorageFileApi from './packages/StorageFileApi'\nimport StorageBucketApi from './packages/StorageBucketApi'\nimport { Fetch } from './lib/fetch'\n\nexport class StorageClient extends StorageBucketApi {\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    super(url, headers, fetch)\n  }\n\n  /**\n   * Perform file operation in a bucket.\n   *\n   * @param id The bucket id to operate on.\n   */\n  from(id: string): StorageFileApi {\n    return new StorageFileApi(this.url, this.headers, id, this.fetch)\n  }\n}\n","export const version = '2.21.0'\n","// constants.ts\nimport { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js/${version}` }\n","import crossFetch, { Headers as CrossFetchHeaders } from 'cross-fetch'\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = crossFetch as unknown as Fetch\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const resolveHeadersConstructor = () => {\n  if (typeof Headers === 'undefined') {\n    return CrossFetchHeaders\n  }\n\n  return Headers\n}\n\nexport const fetchWithAuth = (\n  supabaseKey: string,\n  getAccessToken: () => Promise<string | null>,\n  customFetch?: Fetch\n): Fetch => {\n  const fetch = resolveFetch(customFetch)\n  const HeadersConstructor = resolveHeadersConstructor()\n\n  return async (input, init) => {\n    const accessToken = (await getAccessToken()) ?? supabaseKey\n    let headers = new HeadersConstructor(init?.headers)\n\n    if (!headers.has('apikey')) {\n      headers.set('apikey', supabaseKey)\n    }\n\n    if (!headers.has('Authorization')) {\n      headers.set('Authorization', `Bearer ${accessToken}`)\n    }\n\n    return fetch(input, { ...init, headers })\n  }\n}\n","import { SupportedStorage } from './types'\nexport function expiresAt(expiresIn: number) {\n  const timeNow = Math.round(Date.now() / 1000)\n  return timeNow + expiresIn\n}\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport const isBrowser = () => typeof document !== 'undefined'\n\nconst localStorageWriteTests = {\n  tested: false,\n  writable: false,\n}\n\n/**\n * Checks whether localStorage is supported on this browser.\n */\nexport const supportsLocalStorage = () => {\n  if (!isBrowser()) {\n    return false\n  }\n\n  try {\n    if (typeof globalThis.localStorage !== 'object') {\n      return false\n    }\n  } catch (e) {\n    // DOM exception when accessing `localStorage`\n    return false\n  }\n\n  if (localStorageWriteTests.tested) {\n    return localStorageWriteTests.writable\n  }\n\n  const randomKey = `lswt-${Math.random()}${Math.random()}`\n\n  try {\n    globalThis.localStorage.setItem(randomKey, randomKey)\n    globalThis.localStorage.removeItem(randomKey)\n\n    localStorageWriteTests.tested = true\n    localStorageWriteTests.writable = true\n  } catch (e) {\n    // localStorage can't be written to\n    // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n\n    localStorageWriteTests.tested = true\n    localStorageWriteTests.writable = false\n  }\n\n  return localStorageWriteTests.writable\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) url = window?.location?.href || ''\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const looksLikeFetchResponse = (maybeResponse: unknown): maybeResponse is Response => {\n  return (\n    typeof maybeResponse === 'object' &&\n    maybeResponse !== null &&\n    'status' in maybeResponse &&\n    'ok' in maybeResponse &&\n    'json' in maybeResponse &&\n    typeof (maybeResponse as any).json === 'function'\n  )\n}\n\n// Storage helpers\nexport const setItemAsync = async (\n  storage: SupportedStorage,\n  key: string,\n  data: any\n): Promise<void> => {\n  await storage.setItem(key, JSON.stringify(data))\n}\n\nexport const getItemAsync = async (storage: SupportedStorage, key: string): Promise<unknown> => {\n  const value = await storage.getItem(key)\n\n  if (!value) {\n    return null\n  }\n\n  try {\n    return JSON.parse(value)\n  } catch {\n    return value\n  }\n}\n\nexport const removeItemAsync = async (storage: SupportedStorage, key: string): Promise<void> => {\n  await storage.removeItem(key)\n}\n\nexport function decodeBase64URL(value: string): string {\n  const key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n  let base64 = ''\n  let chr1, chr2, chr3\n  let enc1, enc2, enc3, enc4\n  let i = 0\n  value = value.replace('-', '+').replace('_', '/')\n\n  while (i < value.length) {\n    enc1 = key.indexOf(value.charAt(i++))\n    enc2 = key.indexOf(value.charAt(i++))\n    enc3 = key.indexOf(value.charAt(i++))\n    enc4 = key.indexOf(value.charAt(i++))\n    chr1 = (enc1 << 2) | (enc2 >> 4)\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n    chr3 = ((enc3 & 3) << 6) | enc4\n    base64 = base64 + String.fromCharCode(chr1)\n\n    if (enc3 != 64 && chr2 != 0) {\n      base64 = base64 + String.fromCharCode(chr2)\n    }\n    if (enc4 != 64 && chr3 != 0) {\n      base64 = base64 + String.fromCharCode(chr3)\n    }\n  }\n  return base64\n}\n\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */\nexport class Deferred<T = any> {\n  public static promiseConstructor: PromiseConstructor = Promise\n\n  public readonly promise!: PromiseLike<T>\n\n  public readonly resolve!: (value?: T | PromiseLike<T>) => void\n\n  public readonly reject!: (reason?: any) => any\n\n  public constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\n    ;(this as any).promise = new Deferred.promiseConstructor((res, rej) => {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;(this as any).resolve = res\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;(this as any).reject = rej\n    })\n  }\n}\n\n// Taken from: https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library\nexport function decodeJWTPayload(token: string) {\n  // Regex checks for base64url format\n  const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i\n\n  const parts = token.split('.')\n\n  if (parts.length !== 3) {\n    throw new Error('JWT is not valid: not a JWT structure')\n  }\n\n  if (!base64UrlRegex.test(parts[1])) {\n    throw new Error('JWT is not valid: payload is not in base64url format')\n  }\n\n  const base64Url = parts[1]\n  return JSON.parse(decodeBase64URL(base64Url))\n}\n\n/**\n * Creates a promise that resolves to null after some time.\n */\nexport function sleep(time: number): Promise<null> {\n  return new Promise((accept) => {\n    setTimeout(() => accept(null), time)\n  })\n}\n\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */\nexport function retryable<T>(\n  fn: (attempt: number) => Promise<T>,\n  isRetryable: (attempt: number, error: any | null, result?: T) => boolean\n): Promise<T> {\n  const promise = new Promise<T>((accept, reject) => {\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\n    ;(async () => {\n      for (let attempt = 0; attempt < Infinity; attempt++) {\n        try {\n          const result = await fn(attempt)\n\n          if (!isRetryable(attempt, null, result)) {\n            accept(result)\n            return\n          }\n        } catch (e: any) {\n          if (!isRetryable(attempt, e)) {\n            reject(e)\n            return\n          }\n        }\n      }\n    })()\n  })\n\n  return promise\n}\n\nfunction dec2hex(dec: number) {\n  return ('0' + dec.toString(16)).substr(-2)\n}\n\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nexport function generatePKCEVerifier() {\n  const verifierLength = 56\n  const array = new Uint32Array(verifierLength)\n  if (typeof crypto === 'undefined') {\n    const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~'\n    const charSetLen = charSet.length\n    let verifier = ''\n    for (let i = 0; i < verifierLength; i++) {\n      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen))\n    }\n    return verifier\n  }\n  crypto.getRandomValues(array)\n  return Array.from(array, dec2hex).join('')\n}\n\nasync function sha256(randomString: string) {\n  const encoder = new TextEncoder()\n  const encodedData = encoder.encode(randomString)\n  const hash = await crypto.subtle.digest('SHA-256', encodedData)\n  const bytes = new Uint8Array(hash)\n\n  return Array.from(bytes)\n    .map((c) => String.fromCharCode(c))\n    .join('')\n}\n\nfunction base64urlencode(str: string) {\n  return btoa(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '')\n}\n\nexport async function generatePKCEChallenge(verifier: string) {\n  if (typeof crypto === 'undefined') {\n    console.warn(\n      'WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.'\n    )\n    return verifier\n  }\n  const hashed = await sha256(verifier)\n  return base64urlencode(hashed)\n}\n","export class AuthError extends Error {\n  status: number | undefined\n  protected __isAuthError = true\n\n  constructor(message: string, status?: number) {\n    super(message)\n    this.name = 'AuthError'\n    this.status = status\n  }\n}\n\nexport function isAuthError(error: unknown): error is AuthError {\n  return typeof error === 'object' && error !== null && '__isAuthError' in error\n}\n\nexport class AuthApiError extends AuthError {\n  status: number\n\n  constructor(message: string, status: number) {\n    super(message, status)\n    this.name = 'AuthApiError'\n    this.status = status\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n    }\n  }\n}\n\nexport function isAuthApiError(error: unknown): error is AuthApiError {\n  return isAuthError(error) && error.name === 'AuthApiError'\n}\n\nexport class AuthUnknownError extends AuthError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'AuthUnknownError'\n    this.originalError = originalError\n  }\n}\n\nexport class CustomAuthError extends AuthError {\n  name: string\n  status: number\n  constructor(message: string, name: string, status: number) {\n    super(message)\n    this.name = name\n    this.status = status\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n    }\n  }\n}\n\nexport class AuthSessionMissingError extends CustomAuthError {\n  constructor() {\n    super('Auth session missing!', 'AuthSessionMissingError', 400)\n  }\n}\n\nexport class AuthInvalidCredentialsError extends CustomAuthError {\n  constructor(message: string) {\n    super(message, 'AuthInvalidCredentialsError', 400)\n  }\n}\n\nexport class AuthImplicitGrantRedirectError extends CustomAuthError {\n  details: { error: string; code: string } | null = null\n  constructor(message: string, details: { error: string; code: string } | null = null) {\n    super(message, 'AuthImplicitGrantRedirectError', 500)\n    this.details = details\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      details: this.details,\n    }\n  }\n}\n\nexport class AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n  details: { error: string; code: string } | null = null\n  constructor(message: string, details: { error: string; code: string } | null = null) {\n    super(message, 'AuthPKCEGrantCodeExchangeError', 500)\n    this.details = details\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      details: this.details,\n    }\n  }\n}\n\nexport class AuthRetryableFetchError extends CustomAuthError {\n  constructor(message: string, status: number) {\n    super(message, 'AuthRetryableFetchError', status)\n  }\n}\n","import { expiresAt, looksLikeFetchResponse } from './helpers'\nimport {\n  AuthResponse,\n  SSOResponse,\n  GenerateLinkProperties,\n  GenerateLinkResponse,\n  User,\n  UserResponse,\n} from './types'\nimport { AuthApiError, AuthRetryableFetchError, AuthUnknownError } from './errors'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport interface FetchParameters {\n  signal?: AbortSignal\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst handleError = async (error: unknown, reject: (reason?: any) => void) => {\n  const NETWORK_ERROR_CODES = [502, 503, 504]\n  if (!looksLikeFetchResponse(error)) {\n    reject(new AuthRetryableFetchError(_getErrorMessage(error), 0))\n  } else if (NETWORK_ERROR_CODES.includes(error.status)) {\n    // status in 500...599 range - server had an error, request might be retryed.\n    reject(new AuthRetryableFetchError(_getErrorMessage(error), error.status))\n  } else {\n    // got a response from server that is not in the 500...599 range - should not retry\n    error\n      .json()\n      .then((err) => {\n        reject(new AuthApiError(_getErrorMessage(err), error.status || 500))\n      })\n      .catch((e) => {\n        // not a valid json response\n        reject(new AuthUnknownError(_getErrorMessage(e), e))\n      })\n  }\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET') {\n    return params\n  }\n\n  params.headers = { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers }\n  params.body = JSON.stringify(body)\n  return { ...params, ...parameters }\n}\n\ninterface GotrueRequestOptions extends FetchOptions {\n  jwt?: string\n  redirectTo?: string\n  body?: object\n  query?: { [key: string]: string }\n  /**\n   * Function that transforms api response from gotrue into a desirable / standardised format\n   */\n  xform?: (data: any) => any\n}\n\nexport async function _request(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: GotrueRequestOptions\n) {\n  const headers = { ...options?.headers }\n  if (options?.jwt) {\n    headers['Authorization'] = `Bearer ${options.jwt}`\n  }\n  const qs = options?.query ?? {}\n  if (options?.redirectTo) {\n    qs['redirect_to'] = options.redirectTo\n  }\n  const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : ''\n  const data = await _handleRequest(\n    fetcher,\n    method,\n    url + queryString,\n    { headers, noResolveJson: options?.noResolveJson },\n    {},\n    options?.body\n  )\n  return options?.xform ? options?.xform(data) : { data: { ...data }, error: null }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject))\n  })\n}\n\nexport function _sessionResponse(data: any): AuthResponse {\n  let session = null\n  if (hasSession(data)) {\n    session = { ...data }\n    session.expires_at = expiresAt(data.expires_in)\n  }\n  const user: User = data.user ?? (data as User)\n  return { data: { session, user }, error: null }\n}\n\nexport function _userResponse(data: any): UserResponse {\n  const user: User = data.user ?? (data as User)\n  return { data: { user }, error: null }\n}\n\nexport function _ssoResponse(data: any): SSOResponse {\n  return { data, error: null }\n}\n\nexport function _generateLinkResponse(data: any): GenerateLinkResponse {\n  const { action_link, email_otp, hashed_token, redirect_to, verification_type, ...rest } = data\n\n  const properties: GenerateLinkProperties = {\n    action_link,\n    email_otp,\n    hashed_token,\n    redirect_to,\n    verification_type,\n  }\n\n  const user: User = { ...rest }\n  return {\n    data: {\n      properties,\n      user,\n    },\n    error: null,\n  }\n}\n\nexport function _noResolveJsonResponse(data: any): Response {\n  return data\n}\n\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */\nfunction hasSession(data: any): boolean {\n  return data.access_token && data.refresh_token && data.expires_in\n}\n","import {\n  Fetch,\n  _generateLinkResponse,\n  _noResolveJsonResponse,\n  _request,\n  _userResponse,\n} from './lib/fetch'\nimport { resolveFetch } from './lib/helpers'\nimport {\n  AdminUserAttributes,\n  GenerateLinkParams,\n  GenerateLinkResponse,\n  Pagination,\n  User,\n  UserResponse,\n  GoTrueAdminMFAApi,\n  AuthMFAAdminDeleteFactorParams,\n  AuthMFAAdminDeleteFactorResponse,\n  AuthMFAAdminListFactorsParams,\n  AuthMFAAdminListFactorsResponse,\n  PageParams,\n} from './lib/types'\nimport { AuthError, isAuthError } from './lib/errors'\n\nexport default class GoTrueAdminApi {\n  /** Contains all MFA administration methods. */\n  mfa: GoTrueAdminMFAApi\n\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.fetch = resolveFetch(fetch)\n    this.mfa = {\n      listFactors: this._listFactors.bind(this),\n      deleteFactor: this._deleteFactor.bind(this),\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async signOut(jwt: string): Promise<{ data: null; error: AuthError | null }> {\n    try {\n      await _request(this.fetch, 'POST', `${this.url}/logout`, {\n        headers: this.headers,\n        jwt,\n        noResolveJson: true,\n      })\n      return { data: null, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo A URL or mobile deeplink to send the user to after they are confirmed.\n   * @param options.data Optional user metadata\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/invite`, {\n        body: { email, data: options.data },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates email links and OTPs to be sent via a custom email provider.\n   * @param email The user's email.\n   * @param options.password User password. For signup only.\n   * @param options.data Optional user metadata. For signup only.\n   * @param options.redirectTo The redirect url which should be appended to the generated link\n   */\n  async generateLink(params: GenerateLinkParams): Promise<GenerateLinkResponse> {\n    try {\n      const { options, ...rest } = params\n      const body: any = { ...rest, ...options }\n      if ('newEmail' in rest) {\n        // replace newEmail with new_email in request body\n        body.new_email = rest?.newEmail\n        delete body['newEmail']\n      }\n      return await _request(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\n        body: body,\n        headers: this.headers,\n        xform: _generateLinkResponse,\n        redirectTo: options?.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            properties: null,\n            user: null,\n          },\n          error,\n        }\n      }\n      throw error\n    }\n  }\n\n  // User Admin API\n  /**\n   * Creates a new user.\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async createUser(attributes: AdminUserAttributes): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/admin/users`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n   */\n  async listUsers(\n    params?: PageParams\n  ): Promise<\n    | { data: { users: User[]; aud: string } & Pagination; error: null }\n    | { data: { users: [] }; error: AuthError }\n  > {\n    try {\n      const pagination: Pagination = { nextPage: null, lastPage: 0, total: 0 }\n      const response = await _request(this.fetch, 'GET', `${this.url}/admin/users`, {\n        headers: this.headers,\n        noResolveJson: true,\n        query: {\n          page: params?.page?.toString() ?? '',\n          per_page: params?.perPage?.toString() ?? '',\n        },\n        xform: _noResolveJsonResponse,\n      })\n      if (response.error) throw response.error\n\n      const users = await response.json()\n      const total = response.headers.get('x-total-count') ?? 0\n      const links = response.headers.get('link')?.split(',') ?? []\n      if (links.length > 0) {\n        links.forEach((link: string) => {\n          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1))\n          const rel = JSON.parse(link.split(';')[1].split('=')[1])\n          pagination[`${rel}Page`] = page\n        })\n\n        pagination.total = parseInt(total)\n      }\n      return { data: { ...users, ...pagination }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { users: [] }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(uid: string): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(uid: string, attributes: AdminUserAttributes): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * @param id The user id you want to remove.\n   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema.\n   * Defaults to false for backward compatibility.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async deleteUser(id: string, shouldSoftDelete = false): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\n        headers: this.headers,\n        body: {\n          should_soft_delete: shouldSoftDelete,\n        },\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _listFactors(\n    params: AuthMFAAdminListFactorsParams\n  ): Promise<AuthMFAAdminListFactorsResponse> {\n    try {\n      const { data, error } = await _request(\n        this.fetch,\n        'GET',\n        `${this.url}/admin/users/${params.userId}/factors`,\n        {\n          headers: this.headers,\n          xform: (factors: any) => {\n            return { data: { factors }, error: null }\n          },\n        }\n      )\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _deleteFactor(\n    params: AuthMFAAdminDeleteFactorParams\n  ): Promise<AuthMFAAdminDeleteFactorResponse> {\n    try {\n      const data = await _request(\n        this.fetch,\n        'DELETE',\n        `${this.url}/admin/users/${params.userId}/factors/${params.id}`,\n        {\n          headers: this.headers,\n        }\n      )\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n","// Generated by genversion.\nexport const version = '2.23.0'\n","import { version } from './version'\nexport const GOTRUE_URL = 'http://localhost:9999'\nexport const STORAGE_KEY = 'supabase.auth.token'\nexport const AUDIENCE = ''\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${version}` }\nexport const EXPIRY_MARGIN = 10 // in seconds\nexport const NETWORK_FAILURE = {\n  MAX_RETRIES: 10,\n  RETRY_INTERVAL: 2, // in deciseconds\n}\n","import { supportsLocalStorage } from './helpers'\nimport { SupportedStorage } from './types'\n\nconst localStorageAdapter: SupportedStorage = {\n  getItem: (key) => {\n    if (!supportsLocalStorage()) {\n      return null\n    }\n\n    return globalThis.localStorage.getItem(key)\n  },\n  setItem: (key, value) => {\n    if (!supportsLocalStorage()) {\n      return\n    }\n\n    globalThis.localStorage.setItem(key, value)\n  },\n  removeItem: (key) => {\n    if (!supportsLocalStorage()) {\n      return\n    }\n\n    globalThis.localStorage.removeItem(key)\n  },\n}\n\nexport default localStorageAdapter\n","/**\n * https://mathiasbynens.be/notes/globalthis\n */\nexport function polyfillGlobalThis() {\n  if (typeof globalThis === 'object') return\n  try {\n    Object.defineProperty(Object.prototype, '__magic__', {\n      get: function () {\n        return this\n      },\n      configurable: true,\n    })\n    // @ts-expect-error 'Allow access to magic'\n    __magic__.globalThis = __magic__\n    // @ts-expect-error 'Allow access to magic'\n    delete Object.prototype.__magic__\n  } catch (e) {\n    if (typeof self !== 'undefined') {\n      // @ts-expect-error 'Allow access to globals'\n      self.globalThis = self\n    }\n  }\n}\n","import GoTrueAdminApi from './GoTrueAdminApi'\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants'\nimport {\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthPKCEGrantCodeExchangeError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthUnknownError,\n  isAuthApiError,\n  isAuthError,\n} from './lib/errors'\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\nimport {\n  decodeJWTPayload,\n  Deferred,\n  getItemAsync,\n  getParameterByName,\n  isBrowser,\n  removeItemAsync,\n  resolveFetch,\n  setItemAsync,\n  uuid,\n  retryable,\n  sleep,\n  generatePKCEVerifier,\n  generatePKCEChallenge,\n} from './lib/helpers'\nimport localStorageAdapter from './lib/local-storage'\nimport { polyfillGlobalThis } from './lib/polyfills'\n\nimport type {\n  AuthChangeEvent,\n  AuthResponse,\n  CallRefreshTokenResult,\n  GoTrueClientOptions,\n  InitializeResult,\n  OAuthResponse,\n  SSOResponse,\n  Provider,\n  Session,\n  SignInWithIdTokenCredentials,\n  SignInWithOAuthCredentials,\n  SignInWithPasswordCredentials,\n  SignInWithPasswordlessCredentials,\n  SignUpWithPasswordCredentials,\n  SignInWithSSO,\n  Subscription,\n  SupportedStorage,\n  User,\n  UserAttributes,\n  UserResponse,\n  VerifyOtpParams,\n  GoTrueMFAApi,\n  MFAEnrollParams,\n  AuthMFAEnrollResponse,\n  MFAChallengeParams,\n  AuthMFAChallengeResponse,\n  MFAUnenrollParams,\n  AuthMFAUnenrollResponse,\n  MFAVerifyParams,\n  AuthMFAVerifyResponse,\n  AuthMFAListFactorsResponse,\n  AMREntry,\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\n  AuthenticatorAssuranceLevels,\n  Factor,\n  MFAChallengeAndVerifyParams,\n  AuthFlowType,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit',\n}\n\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 10 * 1000\n\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue admin methods.\n   * These methods should only be used in a trusted server-side environment.\n   */\n  admin: GoTrueAdminApi\n  /**\n   * Namespace for the MFA methods.\n   */\n  mfa: GoTrueMFAApi\n  /**\n   * The storage key used to identify the values saved in localStorage\n   */\n  protected storageKey: string\n\n  /**\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\n   * Only used if persistSession is false.\n   */\n  protected inMemorySession: Session | null\n\n  protected flowType: AuthFlowType\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected storage: SupportedStorage\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected autoRefreshTicker: ReturnType<typeof setInterval> | null = null\n  protected visibilityChangedCallback: (() => Promise<any>) | null = null\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\n  /**\n   * Keeps track of the async client initialization.\n   * When null or not yet resolved the auth state is `unknown`\n   * Once resolved the the auth state is known and it's save to call any further client methods.\n   * Keep extra care to never reject or throw uncaught errors\n   */\n  protected initializePromise: Promise<InitializeResult> | null = null\n  protected detectSessionInUrl = true\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  /**\n   * Used to broadcast state change events to other tabs listening.\n   */\n  protected broadcastChannel: BroadcastChannel | null = null\n\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options: GoTrueClientOptions) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.inMemorySession = null\n    this.storageKey = settings.storageKey\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.storage = settings.storage || localStorageAdapter\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch,\n    })\n\n    this.url = settings.url\n    this.headers = settings.headers\n    this.fetch = resolveFetch(settings.fetch)\n    this.detectSessionInUrl = settings.detectSessionInUrl\n    this.flowType = settings.flowType\n\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n    }\n\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)\n      } catch (e: any) {\n        console.error(\n          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',\n          e\n        )\n      }\n\n      this.broadcastChannel?.addEventListener('message', (event) => {\n        this._notifyAllSubscribers(event.data.event, event.data.session, false) // broadcast = false so we don't get an endless loop of messages\n      })\n    }\n\n    this.initialize()\n  }\n\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize(): Promise<InitializeResult> {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize()\n    }\n\n    return this.initializePromise\n  }\n\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  private async _initialize(): Promise<InitializeResult> {\n    if (this.initializePromise) {\n      return this.initializePromise\n    }\n\n    try {\n      const isPKCEFlow = await this._isPKCEFlow()\n      if ((this.detectSessionInUrl && this._isImplicitGrantFlow()) || isPKCEFlow) {\n        const { data, error } = await this._getSessionFromUrl(isPKCEFlow)\n        if (error) {\n          // failed login attempt via url,\n          // remove old session as in verifyOtp, signUp and signInWith*\n          await this._removeSession()\n\n          return { error }\n        }\n\n        const { session, redirectType } = data\n\n        await this._saveSession(session)\n\n        setTimeout(() => {\n          if (redirectType === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\n          } else {\n            this._notifyAllSubscribers('SIGNED_IN', session)\n          }\n        }, 0)\n\n        return { error: null }\n      }\n\n      // no login attempt via callback url try to recover session from storage\n      await this._recoverAndRefresh()\n      return { error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { error }\n      }\n\n      return {\n        error: new AuthUnknownError('Unexpected error during initialization', error),\n      }\n    } finally {\n      await this._handleVisibilityChange()\n    }\n  }\n\n  /**\n   * Creates a new user.\n   *\n   * Be aware that if a user account exists in the system you may get back an\n   * error message that attempts to hide this information from the user.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          const codeVerifier = generatePKCEVerifier()\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n        }\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            channel: options?.channel ?? 'sms',\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or that the\n   * email/phone and password combination is wrong or that the account can only\n   * be accessed via social login.\n   */\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            email,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n      const { data, error } = res\n      if (error || !data) return { data: { user: null, session: null }, error }\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    await this._removeSession()\n\n    return await this._handleProviderSignIn(credentials.provider, {\n      redirectTo: credentials.options?.redirectTo,\n      scopes: credentials.options?.scopes,\n      queryParams: credentials.options?.queryParams,\n      skipBrowserRedirect: credentials.options?.skipBrowserRedirect,\n    })\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n  async exchangeCodeForSession(authCode: string): Promise<AuthResponse> {\n    const codeVerifier = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    const { data, error } = await _request(\n      this.fetch,\n      'POST',\n      `${this.url}/token?grant_type=pkce`,\n      {\n        headers: this.headers,\n        body: {\n          auth_code: authCode,\n          code_verifier: codeVerifier,\n        },\n        xform: _sessionResponse,\n      }\n    )\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    if (error || !data) return { data: { user: null, session: null }, error }\n    if (data.session) {\n      await this._saveSession(data.session)\n      this._notifyAllSubscribers('SIGNED_IN', data.session)\n    }\n    return { data, error }\n  }\n\n  /**\n   * Allows signing in with an ID token issued by certain supported providers.\n   * The ID token is verified for validity and a new session is established.\n   *\n   * @experimental\n   */\n  async signInWithIdToken(credentials: SignInWithIdTokenCredentials): Promise<AuthResponse> {\n    await this._removeSession()\n\n    try {\n      const { options, provider, token, nonce } = credentials\n\n      const res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n        headers: this.headers,\n        body: {\n          provider,\n          id_token: token,\n          nonce,\n          gotrue_meta_security: { captcha_token: options?.captchaToken },\n        },\n        xform: _sessionResponse,\n      })\n\n      const { data, error } = res\n      if (error || !data) return { data: { user: null, session: null }, error }\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   *\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or, that the account\n   * can only be accessed via social login.\n   *\n   * Do note that you will need to configure a Whatsapp sender on Twilio\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n   * channel is not supported on other providers\n   * at this time.\n   */\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      if ('email' in credentials) {\n        const { email, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          const codeVerifier = generatePKCEVerifier()\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n        }\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            email,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      if ('phone' in credentials) {\n        const { phone, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            phone,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            channel: options?.channel ?? 'sms',\n          },\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\n        headers: this.headers,\n        body: {\n          ...params,\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\n        },\n        redirectTo: params.options?.redirectTo,\n        xform: _sessionResponse,\n      })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw new Error('An error occurred on token verification.')\n      }\n\n      const session: Session | null = data.session\n      const user: User = data.user\n\n      if (session?.access_token) {\n        await this._saveSession(session as Session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   */\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\n    try {\n      await this._removeSession()\n\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\n        body: {\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\n          ...('domain' in params ? { domain: params.domain } : null),\n          redirect_to: params.options?.redirectTo ?? undefined,\n          ...(params?.options?.captchaToken\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n            : null),\n          skip_http_redirect: true, // fetch does not handle redirects\n        },\n        headers: this.headers,\n        xform: _ssoResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  async getSession(): Promise<\n    | {\n        data: {\n          session: Session\n        }\n        error: null\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: AuthError\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: null\n      }\n  > {\n    // make sure we've read the session from the url if there is one\n    // save to just await, as long we make sure _initialize() never throws\n    await this.initializePromise\n\n    let currentSession: Session | null = null\n\n    if (this.persistSession) {\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\n\n      if (maybeSession !== null) {\n        if (this._isValidSession(maybeSession)) {\n          currentSession = maybeSession\n        } else {\n          await this._removeSession()\n        }\n      }\n    } else {\n      currentSession = this.inMemorySession\n    }\n\n    if (!currentSession) {\n      return { data: { session: null }, error: null }\n    }\n\n    const hasExpired = currentSession.expires_at\n      ? currentSession.expires_at <= Date.now() / 1000\n      : false\n    if (!hasExpired) {\n      return { data: { session: currentSession }, error: null }\n    }\n\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n    if (error) {\n      return { data: { session: null }, error }\n    }\n\n    return { data: { session }, error: null }\n  }\n\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  async getUser(jwt?: string): Promise<UserResponse> {\n    try {\n      if (!jwt) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        // Default to Authorization header if there is no existing session\n        jwt = data.session?.access_token ?? undefined\n      }\n\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\n        headers: this.headers,\n        jwt: jwt,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates user data for a logged in user.\n   */\n  async updateUser(\n    attributes: UserAttributes,\n    options: {\n      emailRedirectTo?: string | undefined\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        throw sessionError\n      }\n      if (!sessionData.session) {\n        throw new AuthSessionMissingError()\n      }\n      const session: Session = sessionData.session\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\n        headers: this.headers,\n        redirectTo: options?.emailRedirectTo,\n        body: attributes,\n        jwt: session.access_token,\n        xform: _userResponse,\n      })\n      if (userError) throw userError\n      session.user = data.user as User\n      await this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED', session)\n\n      return { data: { user: session.user }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  private _decodeJWT(jwt: string): {\n    exp?: number\n    aal?: AuthenticatorAssuranceLevels | null\n    amr?: AMREntry[] | null\n  } {\n    return decodeJWTPayload(jwt)\n  }\n\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  async setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      if (!currentSession.access_token || !currentSession.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const timeNow = Date.now() / 1000\n      let expiresAt = timeNow\n      let hasExpired = true\n      let session: Session | null = null\n      const payload = decodeJWTPayload(currentSession.access_token)\n      if (payload.exp) {\n        expiresAt = payload.exp\n        hasExpired = expiresAt <= timeNow\n      }\n\n      if (hasExpired) {\n        const { session: refreshedSession, error } = await this._callRefreshToken(\n          currentSession.refresh_token\n        )\n        if (error) {\n          return { data: { user: null, session: null }, error: error }\n        }\n\n        if (!refreshedSession) {\n          return { data: { user: null, session: null }, error: null }\n        }\n        session = refreshedSession\n      } else {\n        const { data, error } = await this.getUser(currentSession.access_token)\n        if (error) {\n          throw error\n        }\n        session = {\n          access_token: currentSession.access_token,\n          refresh_token: currentSession.refresh_token,\n          user: data.user,\n          token_type: 'bearer',\n          expires_in: expiresAt - timeNow,\n          expires_at: expiresAt,\n        }\n        await this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\n    try {\n      if (!currentSession) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        currentSession = data.session ?? undefined\n      }\n\n      if (!currentSession?.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n      if (error) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      if (!session) {\n        return { data: { user: null, session: null }, error: null }\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets the session data from a URL string\n   */\n  private async _getSessionFromUrl(isPKCEFlow: boolean): Promise<\n    | {\n        data: { session: Session; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; redirectType: null }; error: AuthError }\n  > {\n    try {\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\n      if (this.flowType === 'implicit' && !this._isImplicitGrantFlow()) {\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\n      } else if (this.flowType == 'pkce' && !isPKCEFlow) {\n        throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.')\n      }\n      if (isPKCEFlow) {\n        const authCode = getParameterByName('code')\n        if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.')\n        const { data, error } = await this.exchangeCodeForSession(authCode)\n        if (error) throw error\n        if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.')\n        return { data: { session: data.session, redirectType: null }, error: null }\n      }\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) {\n        const error_code = getParameterByName('error_code')\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\n        const error = getParameterByName('error')\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\n\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\n      }\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { data, error } = await this.getUser(access_token)\n      if (error) throw error\n      const user: User = data.user\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user,\n      }\n      const redirectType = getParameterByName('type')\n\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: { session, redirectType }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  private _isImplicitGrantFlow(): boolean {\n    return (\n      isBrowser() &&\n      (Boolean(getParameterByName('access_token')) ||\n        Boolean(getParameterByName('error_description')))\n    )\n  }\n  /**\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n   */\n  private async _isPKCEFlow(): Promise<boolean> {\n    const currentStorageContent = await getItemAsync(\n      this.storage,\n      `${this.storageKey}-code-verifier`\n    )\n    return isBrowser() && Boolean(getParameterByName('code')) && Boolean(currentStorageContent)\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  async signOut(): Promise<{ error: AuthError | null }> {\n    const { data, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { error: sessionError }\n    }\n    const accessToken = data.session?.access_token\n    if (accessToken) {\n      const { error } = await this.admin.signOut(accessToken)\n      if (error) {\n        // ignore 404s since user might not exist anymore\n        // ignore 401s since an invalid or expired JWT should sign out the current session\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n          return { error }\n        }\n      }\n    }\n    await this._removeSession()\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    this._notifyAllSubscribers('SIGNED_OUT', null)\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: { subscription: Subscription }\n  } {\n    const id: string = uuid()\n    const subscription: Subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id)\n      },\n    }\n\n    this.stateChangeEmitters.set(id, subscription)\n\n    this.emitInitialSession(id)\n\n    return { data: { subscription } }\n  }\n\n  private async emitInitialSession(id: string): Promise<void> {\n    try {\n      const {\n        data: { session },\n        error,\n      } = await this.getSession()\n      if (error) throw error\n\n      this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', session)\n    } catch (err) {\n      this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', null)\n      console.error(err)\n    }\n  }\n\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    let codeChallenge: string | null = null\n    let codeChallengeMethod: string | null = null\n    if (this.flowType === 'pkce') {\n      const codeVerifier = generatePKCEVerifier()\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n      codeChallenge = await generatePKCEChallenge(codeVerifier)\n      codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n    }\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\n        body: {\n          email,\n          code_challenge: codeChallenge,\n          code_challenge_method: codeChallengeMethod,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\n    try {\n      const startedAt = Date.now()\n\n      // will attempt to refresh the token with exponential backoff\n      return await retryable(\n        async (attempt) => {\n          await sleep(attempt * 200) // 0, 200, 400, 800, ...\n\n          return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n            body: { refresh_token: refreshToken },\n            headers: this.headers,\n            xform: _sessionResponse,\n          })\n        },\n        (attempt, _, result) =>\n          result &&\n          result.error &&\n          result.error instanceof AuthRetryableFetchError &&\n          // retryable only if the request can be sent before the backoff overflows the tick duration\n          Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n      throw error\n    }\n  }\n\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\n    const isValidSession =\n      typeof maybeSession === 'object' &&\n      maybeSession !== null &&\n      'access_token' in maybeSession &&\n      'refresh_token' in maybeSession &&\n      'expires_at' in maybeSession\n\n    return isValidSession\n  }\n\n  private async _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n      skipBrowserRedirect?: boolean\n    }\n  ) {\n    const url: string = await this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n    // try to open on the browser\n    if (isBrowser() && !options.skipBrowserRedirect) {\n      window.location.assign(url)\n    }\n\n    return { data: { provider, url }, error: null }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\n      if (!this._isValidSession(currentSession)) {\n        if (currentSession !== null) {\n          await this._removeSession()\n        }\n\n        return\n      }\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n\n          if (error) {\n            console.log(error.message)\n            await this._removeSession()\n          }\n        } else {\n          await this._removeSession()\n        }\n      } else {\n        if (this.persistSession) {\n          await this._saveSession(currentSession)\n        }\n        this._notifyAllSubscribers('SIGNED_IN', currentSession)\n      }\n    } catch (err) {\n      console.error(err)\n      return\n    }\n  }\n\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\n    // refreshing is already in progress\n    if (this.refreshingDeferred) {\n      return this.refreshingDeferred.promise\n    }\n\n    try {\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\n\n      if (!refreshToken) {\n        throw new AuthSessionMissingError()\n      }\n      const { data, error } = await this._refreshAccessToken(refreshToken)\n      if (error) throw error\n      if (!data.session) throw new AuthSessionMissingError()\n\n      await this._saveSession(data.session)\n      this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\n\n      const result = { session: data.session, error: null }\n\n      this.refreshingDeferred.resolve(result)\n\n      return result\n    } catch (error) {\n      if (isAuthError(error)) {\n        const result = { session: null, error }\n\n        this.refreshingDeferred?.resolve(result)\n\n        return result\n      }\n\n      this.refreshingDeferred?.reject(error)\n      throw error\n    } finally {\n      this.refreshingDeferred = null\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent, session: Session | null, broadcast = true) {\n    if (this.broadcastChannel && broadcast) {\n      this.broadcastChannel.postMessage({ event, session })\n    }\n\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private async _saveSession(session: Session) {\n    if (!this.persistSession) {\n      this.inMemorySession = session\n    }\n\n    if (this.persistSession && session.expires_at) {\n      await this._persistSession(session)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    return setItemAsync(this.storage, this.storageKey, currentSession)\n  }\n\n  private async _removeSession() {\n    if (this.persistSession) {\n      await removeItemAsync(this.storage, this.storageKey)\n    } else {\n      this.inMemorySession = null\n    }\n  }\n\n  /**\n   * Removes any registered visibilitychange callback.\n   *\n   * {@see #startAutoRefresh}\n   * {@see #stopAutoRefresh}\n   */\n  private _removeVisibilityChangedCallback() {\n    const callback = this.visibilityChangedCallback\n    this.visibilityChangedCallback = null\n\n    try {\n      if (callback && isBrowser() && window?.removeEventListener) {\n        window.removeEventListener('visibilitychange', callback)\n      }\n    } catch (e) {\n      console.error('removing visibilitychange callback failed', e)\n    }\n  }\n\n  /**\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _startAutoRefresh() {\n    await this._stopAutoRefresh()\n\n    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION)\n    this.autoRefreshTicker = ticker\n\n    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n      // ticker is a NodeJS Timeout object that has an `unref` method\n      // https://nodejs.org/api/timers.html#timeoutunref\n      // When auto refresh is used in NodeJS (like for testing) the\n      // `setInterval` is preventing the process from being marked as\n      // finished and tests run endlessly. This can be prevented by calling\n      // `unref()` on the returned object.\n      ticker.unref()\n      // @ts-ignore\n    } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n      // similar like for NodeJS, but with the Deno API\n      // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n      // @ts-ignore\n      Deno.unrefTimer(ticker)\n    }\n\n    // run the tick immediately\n    await this._autoRefreshTokenTick()\n  }\n\n  /**\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _stopAutoRefresh() {\n    const ticker = this.autoRefreshTicker\n    this.autoRefreshTicker = null\n\n    if (ticker) {\n      clearInterval(ticker)\n    }\n  }\n\n  /**\n   * Starts an auto-refresh process in the background. The session is checked\n   * every few seconds. Close to the time of expiration a process is started to\n   * refresh the session. If refreshing fails it will be retried for as long as\n   * necessary.\n   *\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n   * to call this function, it will be called for you.\n   *\n   * On browsers the refresh process works only when the tab/window is in the\n   * foreground to conserve resources as well as prevent race conditions and\n   * flooding auth with requests. If you call this method any managed\n   * visibility change callback will be removed and you must manage visibility\n   * changes on your own.\n   *\n   * On non-browser platforms the refresh process works *continuously* in the\n   * background, which may not be desireable. You should hook into your\n   * platform's foreground indication mechanism and call these methods\n   * appropriately to conserve resources.\n   *\n   * {@see #stopAutoRefresh}\n   */\n  async startAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._startAutoRefresh()\n  }\n\n  /**\n   * Stops an active auto refresh process running in the background (if any).\n   *\n   * If you call this method any managed visibility change callback will be\n   * removed and you must manage visibility changes on your own.\n   *\n   * See {@link #startAutoRefresh} for more details.\n   */\n  async stopAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._stopAutoRefresh()\n  }\n\n  /**\n   * Runs the auto refresh token tick.\n   */\n  private async _autoRefreshTokenTick() {\n    const now = Date.now()\n\n    try {\n      const {\n        data: { session },\n      } = await this.getSession()\n\n      if (!session || !session.refresh_token || !session.expires_at) {\n        return\n      }\n\n      // session will expire in this many ticks (or has already expired if <= 0)\n      const expiresInTicks = Math.floor(\n        (session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION\n      )\n\n      if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n        await this._callRefreshToken(session.refresh_token)\n      }\n    } catch (e: any) {\n      console.error('Auto refresh tick failed with error. This is likely a transient error.', e)\n    }\n  }\n\n  /**\n   * Registers callbacks on the browser / platform, which in-turn run\n   * algorithms when the browser window/tab are in foreground. On non-browser\n   * platforms it assumes always foreground.\n   */\n  private async _handleVisibilityChange() {\n    if (!isBrowser() || !window?.addEventListener) {\n      if (this.autoRefreshToken) {\n        // in non-browser environments the refresh token ticker runs always\n        this.startAutoRefresh()\n      }\n\n      return false\n    }\n\n    try {\n      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false)\n\n      window?.addEventListener('visibilitychange', this.visibilityChangedCallback)\n\n      // now immediately call the visbility changed callback to setup with the\n      // current visbility state\n      await this._onVisibilityChanged(true) // initial call\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n\n  /**\n   * Callback registered with `window.addEventListener('visibilitychange')`.\n   */\n  private async _onVisibilityChanged(isInitial: boolean) {\n    if (document.visibilityState === 'visible') {\n      if (!isInitial) {\n        // initial visibility change setup is handled in another flow under #initialize()\n        await this.initializePromise\n        await this._recoverAndRefresh()\n      }\n\n      if (this.autoRefreshToken) {\n        // in browser environments the refresh token ticker runs only on focused tabs\n        // which prevents race conditions\n        this._startAutoRefresh()\n      }\n    } else if (document.visibilityState === 'hidden') {\n      if (this.autoRefreshToken) {\n        this._stopAutoRefresh()\n      }\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  private async _getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (this.flowType === 'pkce') {\n      const codeVerifier = generatePKCEVerifier()\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n      const codeChallenge = await generatePKCEChallenge(codeVerifier)\n      const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n      const flowParams = new URLSearchParams({\n        code_challenge: `${encodeURIComponent(codeChallenge)}`,\n        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\n      })\n      urlParams.push(flowParams.toString())\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(query.toString())\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#enroll}\n   */\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\n        body: {\n          friendly_name: params.friendlyName,\n          factor_type: params.factorType,\n          issuer: params.issuer,\n        },\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n\n      if (error) {\n        return { data: null, error }\n      }\n\n      if (data?.totp?.qr_code) {\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#verify}\n   */\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/verify`,\n        {\n          body: { code: params.code, challenge_id: params.challengeId },\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n      if (error) {\n        return { data: null, error }\n      }\n\n      await this._saveSession({\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\n        ...data,\n      })\n      this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\n\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challenge}\n   */\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/challenge`,\n        {\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challengeAndVerify}\n   */\n  private async _challengeAndVerify(\n    params: MFAChallengeAndVerifyParams\n  ): Promise<AuthMFAVerifyResponse> {\n    const { data: challengeData, error: challengeError } = await this._challenge({\n      factorId: params.factorId,\n    })\n    if (challengeError) {\n      return { data: null, error: challengeError }\n    }\n    return await this._verify({\n      factorId: params.factorId,\n      challengeId: challengeData.id,\n      code: params.code,\n    })\n  }\n\n  /**\n   * {@see GoTrueMFAApi#listFactors}\n   */\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\n    const {\n      data: { user },\n      error: userError,\n    } = await this.getUser()\n    if (userError) {\n      return { data: null, error: userError }\n    }\n\n    const factors = user?.factors || []\n    const totp = factors.filter(\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\n    )\n\n    return {\n      data: {\n        all: factors,\n        totp,\n      },\n      error: null,\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n   */\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\n    const {\n      data: { session },\n      error: sessionError,\n    } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n    if (!session) {\n      return {\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n        error: null,\n      }\n    }\n\n    const payload = this._decodeJWT(session.access_token)\n\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\n\n    if (payload.aal) {\n      currentLevel = payload.aal\n    }\n\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\n\n    const verifiedFactors =\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\n\n    if (verifiedFactors.length > 0) {\n      nextLevel = 'aal2'\n    }\n\n    const currentAuthenticationMethods = payload.amr || []\n\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\n  }\n}\n","import { GoTrueClient } from '@supabase/gotrue-js'\nimport { SupabaseAuthClientOptions } from './types'\n\nexport class SupabaseAuthClient extends GoTrueClient {\n  constructor(options: SupabaseAuthClientOptions) {\n    super(options)\n  }\n}\n","import { FunctionsClient } from '@supabase/functions-js'\nimport { AuthChangeEvent } from '@supabase/gotrue-js'\nimport {\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n} from '@supabase/postgrest-js'\nimport {\n  RealtimeChannel,\n  RealtimeChannelOptions,\n  RealtimeClient,\n  RealtimeClientOptions,\n} from '@supabase/realtime-js'\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\nimport { DEFAULT_HEADERS } from './lib/constants'\nimport { fetchWithAuth } from './lib/fetch'\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { Fetch, GenericSchema, SupabaseClientOptions, SupabaseAuthClientOptions } from './lib/types'\n\nconst DEFAULT_GLOBAL_OPTIONS = {\n  headers: DEFAULT_HEADERS,\n}\n\nconst DEFAULT_DB_OPTIONS = {\n  schema: 'public',\n}\n\nconst DEFAULT_AUTH_OPTIONS: SupabaseAuthClientOptions = {\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  flowType: 'implicit',\n}\n\nconst DEFAULT_REALTIME_OPTIONS: RealtimeClientOptions = {}\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n  realtime: RealtimeClient\n\n  protected realtimeUrl: string\n  protected authUrl: string\n  protected storageUrl: string\n  protected functionsUrl: string\n  protected rest: PostgrestClient<Database, SchemaName>\n  protected storageKey: string\n  protected fetch?: Fetch\n  protected changedAccessToken: string | undefined\n\n  protected headers: {\n    [key: string]: string\n  }\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions<SchemaName>\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\n\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws')\n    this.authUrl = `${_supabaseUrl}/auth/v1`\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\n\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/)\n    if (isPlatform) {\n      const urlParts = _supabaseUrl.split('.')\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`\n    } else {\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`\n    }\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\n      global: DEFAULT_GLOBAL_OPTIONS,\n    }\n\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\n\n    this.storageKey = settings.auth?.storageKey ?? ''\n    this.headers = settings.global?.headers ?? {}\n\n    this.auth = this._initSupabaseAuthClient(\n      settings.auth ?? {},\n      this.headers,\n      settings.global?.fetch\n    )\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global?.fetch)\n\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: settings.db?.schema,\n      fetch: this.fetch,\n    })\n\n    this._listenForAuthEvents()\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch,\n    })\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch)\n  }\n\n  /**\n   * Perform a table operation.\n   *\n   * @param table The table name to operate on.\n   */\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View>\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\n    return this.rest.from(relation)\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn  The function name to call.\n   * @param args  The parameters to pass to the function call.\n   * @param options.head   When set to true, no data will be returned.\n   * @param options.count  Count algorithm to use to count rows in a table.\n   *\n   */\n  rpc<\n    FunctionName extends string & keyof Schema['Functions'],\n    Function_ extends Schema['Functions'][FunctionName]\n  >(\n    fn: FunctionName,\n    args: Function_['Args'] = {},\n    options?: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    Schema,\n    Function_['Returns'] extends any[]\n      ? Function_['Returns'][number] extends Record<string, unknown>\n        ? Function_['Returns'][number]\n        : never\n      : never,\n    Function_['Returns']\n  > {\n    return this.rest.rpc(fn, args, options)\n  }\n\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\n    return this.realtime.channel(name, opts)\n  }\n\n  /**\n   * Returns all Realtime channels.\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.realtime.getChannels()\n  }\n\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\n    return this.realtime.removeChannel(channel)\n  }\n\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\n    return this.realtime.removeAllChannels()\n  }\n\n  private async _getAccessToken() {\n    const { data } = await this.auth.getSession()\n\n    return data.session?.access_token ?? null\n  }\n\n  private _initSupabaseAuthClient(\n    {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      storageKey,\n      flowType,\n    }: SupabaseAuthClientOptions,\n    headers?: Record<string, string>,\n    fetch?: Fetch\n  ) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: { ...authHeaders, ...headers },\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      flowType,\n      fetch,\n    })\n  }\n\n  private _initRealtimeClient(options: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl, {\n      ...options,\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\n    })\n  }\n\n  private _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session?.access_token, 'CLIENT')\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    token: string | undefined,\n    source: 'CLIENT' | 'STORAGE'\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      // Token has changed\n      this.realtime.setAuth(token ?? null)\n\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT') {\n      // Token is removed\n      this.realtime.setAuth(this.supabaseKey)\n      if (source == 'STORAGE') this.auth.signOut()\n      this.changedAccessToken = undefined\n    }\n  }\n}\n","// helpers.ts\nimport { SupabaseClientOptions } from './types'\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport function stripTrailingSlash(url: string): string {\n  return url.replace(/\\/$/, '')\n}\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport function applySettingDefaults<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database\n>(\n  options: SupabaseClientOptions<SchemaName>,\n  defaults: SupabaseClientOptions<any>\n): SupabaseClientOptions<SchemaName> {\n  const {\n    db: dbOptions,\n    auth: authOptions,\n    realtime: realtimeOptions,\n    global: globalOptions,\n  } = options\n  const {\n    db: DEFAULT_DB_OPTIONS,\n    auth: DEFAULT_AUTH_OPTIONS,\n    realtime: DEFAULT_REALTIME_OPTIONS,\n    global: DEFAULT_GLOBAL_OPTIONS,\n  } = defaults\n\n  return {\n    db: {\n      ...DEFAULT_DB_OPTIONS,\n      ...dbOptions,\n    },\n    auth: {\n      ...DEFAULT_AUTH_OPTIONS,\n      ...authOptions,\n    },\n    realtime: {\n      ...DEFAULT_REALTIME_OPTIONS,\n      ...realtimeOptions,\n    },\n    global: {\n      ...DEFAULT_GLOBAL_OPTIONS,\n      ...globalOptions,\n    },\n  }\n}\n","import SupabaseClient from './SupabaseClient'\nimport type { GenericSchema, SupabaseClientOptions } from './lib/types'\n\nexport * from '@supabase/gotrue-js'\nexport type { User as AuthUser, Session as AuthSession } from '@supabase/gotrue-js'\nexport type {\n  PostgrestResponse,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  PostgrestError,\n} from '@supabase/postgrest-js'\nexport {\n  FunctionsHttpError,\n  FunctionsFetchError,\n  FunctionsRelayError,\n  FunctionsError,\n} from '@supabase/functions-js'\nexport * from '@supabase/realtime-js'\nexport { default as SupabaseClient } from './SupabaseClient'\nexport type { SupabaseClientOptions } from './lib/types'\n\n/**\n * Creates a new Supabase Client.\n */\nexport const createClient = <\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n>(\n  supabaseUrl: string,\n  supabaseKey: string,\n  options?: SupabaseClientOptions<SchemaName>\n): SupabaseClient<Database, SchemaName, Schema> => {\n  return new SupabaseClient(supabaseUrl, supabaseKey, options)\n}\n","var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n"],"names":["FunctionsError","Error","constructor","message","name","arguments","length","undefined","context","super","this","FunctionsFetchError","FunctionsRelayError","FunctionsHttpError","FunctionsClient","url","headers","customFetch","fetch","_fetch","_len","args","Array","_key","__awaiter","resolveFetch","setAuth","token","Authorization","concat","invoke","functionName","options","method","body","functionArgs","_headers","Object","prototype","hasOwnProperty","call","Blob","ArrayBuffer","FormData","JSON","stringify","response","assign","catch","fetchError","isRelayError","get","ok","data","responseType","_a","split","trim","json","blob","formData","text","error","PostgrestBuilder","builder","shouldThrowOnError","schema","signal","allowEmpty","crossFetch","throwOnError","then","onfulfilled","onrejected","includes","res","toString","async","count","status","statusText","parse","countHeader","match","contentRange","_b","parseInt","isArray","_d","_c","details","stack","hint","code","PostgrestTransformBuilder","select","columns","quoted","cleanedColumns","map","c","test","join","searchParams","set","order","column","ascending","nullsFirst","foreignTable","key","existingOrder","limit","range","from","to","keyOffset","keyLimit","abortSignal","single","maybeSingle","csv","geojson","explain","analyze","verbose","settings","buffers","wal","format","filter","Boolean","forMediatype","rollback","returns","PostgrestFilterBuilder","eq","value","append","neq","gt","gte","lt","lte","like","pattern","likeAllOf","patterns","likeAnyOf","ilike","ilikeAllOf","ilikeAnyOf","is","in","values","cleanedValues","s","RegExp","contains","containedBy","rangeGt","rangeGte","rangeLt","rangeLte","rangeAdjacent","overlaps","textSearch","query","config","type","typePart","configPart","entries","forEach","_ref","not","operator","or","filters","PostgrestQueryBuilder","head","insert","defaultToNull","prefersHeaders","push","reduce","acc","x","keys","uniqueColumns","Set","upsert","onConflict","ignoreDuplicates","update","delete","unshift","DEFAULT_HEADERS","PostgrestClient","relation","URL","rpc","fn","SOCKET_STATES","CHANNEL_STATES","CHANNEL_EVENTS","TRANSPORTS","CONNECTION_STATE","REALTIME_PRESENCE_LISTEN_EVENTS","PostgresTypes","Timer","callback","timerCalc","timer","tries","reset","clearTimeout","scheduleTimeout","setTimeout","Serializer","HEADER_LENGTH","decode","rawPayload","_binaryDecode","buffer","view","DataView","decoder","TextDecoder","_decodeBroadcast","topicSize","getUint8","eventSize","offset","topic","slice","event","ref","payload","byteLength","Push","channel","timeout","sent","timeoutTimer","receivedResp","recHooks","refEvent","rateLimited","resend","_cancelRefEvent","send","_hasReceived","startTimeout","socket","join_ref","_joinRef","updatePayload","receive","_makeRef","_replyEventName","_on","_cancelTimeout","_matchReceive","trigger","_trigger","destroy","_off","h","RealtimePresence","opts","state","pendingDiffs","joinRef","caller","onJoin","onLeave","onSync","events","diff","newState","syncState","syncDiff","inPendingSyncState","currentPresences","newPresences","leftPresences","static","currentState","cloneDeep","transformedState","transformState","joins","leaves","presences","newPresenceRefs","m","presence_ref","curPresenceRefs","joinedPresences","indexOf","joinedPresenceRefs","curPresences","presenceRefsToRemove","obj","func","getOwnPropertyNames","metas","presence","convertChangeData","record","skipTypes","rec_key","convertColumn","columnName","find","colType","convertCell","noop","charAt","dataType","toArray","bool","toBoolean","float4","float8","int2","int4","int8","numeric","oid","toNumber","jsonb","toJson","timestamp","toTimestampString","abstime","date","daterange","int4range","int8range","money","reltime","time","timestamptz","timetz","tsrange","tstzrange","parsedValue","parseFloat","Number","isNaN","console","log","lastIdx","closeBrace","arr","valTrim","_","val","replace","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","RealtimeChannel","params","bindings","closed","joinedOnce","pushBuffer","broadcast","ack","self","joinPush","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","joined","pushEvent","_onClose","_remove","_onError","reason","_isLeaving","_isClosed","errored","_isJoining","reply","subscribe","e","accessTokenPayload","postgres_changes","r","accessToken","access_token","updateJoinPayload","_rejoin","_ref2","serverPostgresFilters","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","table","serverPostgresFilter","unsubscribe","id","presenceState","track","untrack","on","Promise","resolve","_push","leaving","onClose","close","leavePush","leave","_canPush","_onMessage","_event","_isMember","typeLower","toLocaleLowerCase","handledPayload","bind","bindId","bindEvent","ids","_e","_f","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","isEqual","obj1","obj2","k","isConnected","_leaveOpenTopic","records","Transformers","old_record","RealtimeClient","endPoint","channels","transport","w3cwebsocket","heartbeatIntervalMs","heartbeatTimer","pendingHeartbeatRef","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","eventsPerSecondLimitMs","inThrottle","websocket","eventsPerSecond","Math","floor","encode","reconnectTimer","disconnect","connect","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnMessage","onclose","_onConnClose","clearInterval","getChannels","removeChannel","removeAllChannels","values_1","all","kind","msg","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","chan","result","_throttle","newRef","dupChannel","_appendParams","vsn","rawMessage","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","prefix","URLSearchParams","StorageError","__isStorageError","isStorageError","StorageApiError","toJSON","StorageUnknownError","originalError","_getErrorMessage","err","error_description","handleError","reject","Res","Response","_getRequestParams","parameters","_handleRequest","fetcher","noResolveJson","post","remove","DEFAULT_SEARCH_OPTIONS","sortBy","DEFAULT_FILE_OPTIONS","cacheControl","contentType","StorageFileApi","bucketId","uploadOrUpdate","path","fileBody","fileOptions","String","cleanPath","_removeEmptyFolders","_path","_getFinalPath","duplex","upload","uploadToSignedUrl","createSignedUploadUrl","signedUrl","move","fromPath","toPath","sourceKey","destinationKey","copy","Key","createSignedUrl","expiresIn","transform","downloadQueryParam","download","encodeURI","signedURL","createSignedUrls","paths","datum","renderPath","transformationQuery","transformOptsToQueryString","queryString","getPublicUrl","_queryString","publicUrl","prefixes","list","width","height","resize","quality","StorageBucketApi","listBuckets","getBucket","createBucket","public","file_size_limit","fileSizeLimit","allowed_mime_types","allowedMimeTypes","updateBucket","put","emptyBucket","deleteBucket","StorageClient","fetchWithAuth","supabaseKey","getAccessToken","HeadersConstructor","Headers","CrossFetchHeaders","input","init","has","isBrowser","document","localStorageWriteTests","tested","writable","supportsLocalStorage","globalThis","localStorage","randomKey","random","setItem","removeItem","getParameterByName","window","location","href","results","exec","decodeURIComponent","setItemAsync","storage","getItemAsync","getItem","removeItemAsync","Deferred","promise","promiseConstructor","rej","decodeJWTPayload","parts","base64Url","chr1","chr2","chr3","enc1","enc2","enc3","enc4","base64","fromCharCode","decodeBase64URL","dec2hex","dec","substr","generatePKCEVerifier","array","Uint32Array","crypto","charSet","charSetLen","verifier","getRandomValues","generatePKCEChallenge","warn","hashed","randomString","encodedData","TextEncoder","hash","subtle","digest","bytes","Uint8Array","sha256","btoa","AuthError","__isAuthError","isAuthError","AuthApiError","AuthUnknownError","CustomAuthError","AuthSessionMissingError","AuthInvalidCredentialsError","AuthImplicitGrantRedirectError","AuthPKCEGrantCodeExchangeError","AuthRetryableFetchError","maybeResponse","_request","jwt","qs","redirectTo","xform","_sessionResponse","session","refresh_token","expires_in","hasSession","expires_at","round","Date","now","user","_userResponse","_ssoResponse","_generateLinkResponse","action_link","email_otp","hashed_token","redirect_to","verification_type","rest","__rest","properties","_noResolveJsonResponse","GoTrueAdminApi","mfa","listFactors","_listFactors","deleteFactor","_deleteFactor","signOut","inviteUserByEmail","email","generateLink","new_email","newEmail","createUser","attributes","listUsers","pagination","nextPage","lastPage","total","page","per_page","perPage","users","links","_g","link","substring","rel","getUserById","uid","updateUserById","deleteUser","shouldSoftDelete","should_soft_delete","userId","factors","defineProperty","configurable","__magic__","polyfillGlobalThis","DEFAULT_OPTIONS","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","flowType","AUTO_REFRESH_TICK_DURATION","GoTrueClient","stateChangeEmitters","Map","autoRefreshTicker","visibilityChangedCallback","refreshingDeferred","initializePromise","broadcastChannel","inMemorySession","localStorageAdapter","admin","verify","_verify","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","BroadcastChannel","addEventListener","_notifyAllSubscribers","initialize","_initialize","isPKCEFlow","_isPKCEFlow","_isImplicitGrantFlow","_getSessionFromUrl","_removeSession","redirectType","_saveSession","_recoverAndRefresh","_handleVisibilityChange","signUp","credentials","password","codeChallenge","codeChallengeMethod","codeVerifier","emailRedirectTo","gotrue_meta_security","captcha_token","captchaToken","code_challenge","code_challenge_method","phone","signInWithPassword","signInWithOAuth","_handleProviderSignIn","provider","scopes","queryParams","skipBrowserRedirect","exchangeCodeForSession","authCode","auth_code","code_verifier","signInWithIdToken","nonce","id_token","signInWithOtp","create_user","shouldCreateUser","verifyOtp","signInWithSSO","provider_id","providerId","domain","skip_http_redirect","getSession","currentSession","maybeSession","_isValidSession","_callRefreshToken","getUser","updateUser","sessionData","sessionError","userError","_decodeJWT","setSession","timeNow","expiresAt","hasExpired","exp","refreshedSession","token_type","refreshSession","error_code","provider_token","provider_refresh_token","currentStorageContent","isAuthApiError","onAuthStateChange","subscription","emitInitialSession","resetPasswordForEmail","_refreshAccessToken","refreshToken","startedAt","isRetryable","accept","attempt","Infinity","retryable","_getUrlForProvider","postMessage","_persistSession","_removeVisibilityChangedCallback","removeEventListener","_startAutoRefresh","_stopAutoRefresh","ticker","_autoRefreshTokenTick","unref","Deno","unrefTimer","startAutoRefresh","stopAutoRefresh","_onVisibilityChanged","isInitial","visibilityState","urlParams","encodeURIComponent","flowParams","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","challengeData","challengeError","factor","currentLevel","nextLevel","currentAuthenticationMethods","aal","amr","SupabaseAuthClient","DEFAULT_GLOBAL_OPTIONS","DEFAULT_DB_OPTIONS","DEFAULT_AUTH_OPTIONS","DEFAULT_REALTIME_OPTIONS","SupabaseClient","supabaseUrl","_supabaseUrl","realtimeUrl","authUrl","storageUrl","urlParts","functionsUrl","defaultStorageKey","hostname","defaults","db","dbOptions","auth","authOptions","realtime","realtimeOptions","global","globalOptions","applySettingDefaults","_initSupabaseAuthClient","_getAccessToken","_initRealtimeClient","_h","_listenForAuthEvents","functions","SupabaseStorageClient","authHeaders","apikey","_handleTokenChanged","source","changedAccessToken","createClient","__self__","F","DOMException","exports","support","iterable","Symbol","arrayBuffer","viewClasses","isArrayBufferView","isView","normalizeName","TypeError","toLowerCase","normalizeValue","iteratorFor","items","iterator","next","shift","done","header","consumed","bodyUsed","fileReaderReady","reader","onload","readBlobAsArrayBuffer","FileReader","readAsArrayBuffer","bufferClone","buf","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","_bodyFormData","_bodyArrayBuffer","rejected","readAsText","readBlobAsText","chars","readArrayBufferAsText","oldValue","thisArg","methods","Request","mode","upcased","toUpperCase","normalizeMethod","referrer","form","parseHeaders","rawHeaders","line","bodyInit","clone","redirectStatuses","redirect","RangeError","create","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","getAllResponseHeaders","responseURL","responseText","ontimeout","onabort","withCredentials","setRequestHeader","onreadystatechange","polyfill","ponyfill","ctx","module","naiveFallback","__global__","_globalThis","require","NativeWebSocket","WebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","protocols","prop"],"sourceRoot":""}